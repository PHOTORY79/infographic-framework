<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>인포그래픽 포토리 프레임워크</title>
  <link rel="stylesheet" href="styles.css">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome 아이콘 사용을 위한 CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
  <div class="container">
    <header class="header">
      <h1>인포그래픽 프레임워크</h1>
      <p>CSV 데이터를 구조화된 인포그래픽으로 변환하는 도구</p>
    </header>

  <!-- 1) CSV 입력 -->
<section id="input-section" class="my-4">
  <h2>CSV 데이터 입력</h2>
  <textarea id="csv-input" class="form-control" rows="6"
    placeholder="여기에 AI가 생성한 완성된 CSV를 붙여넣으세요"></textarea>
  <div class="mt-2">
    <button id="generate-button" class="btn btn-primary">
      <i class="fas fa-magic"></i> 인포그래픽 생성
    </button>
    <button id="clear-button" class="btn btn-secondary">
      <i class="fas fa-eraser"></i> 초기화
    </button>

  </div>
</section>

<!-- 2) 미리보기 -->
<section id="preview-section" class="my-4">
  <h2>미리보기</h2>
  <div id="preview-container" class="border p-3" style="min-height:200px;">
    <!-- 인포그래픽 SVG가 렌더링됩니다 -->
  </div>
</section>

<!-- 3) 내보내기 -->
<section id="export-section" class="my-4">
  <h2>내보내기</h2>
  <button id="download-button" class="btn btn-success" disabled>
    <i class="fas fa-download"></i> SVG 다운로드
  </button>
  <button id="copy-svg-button" class="btn btn-secondary" disabled>
    <i class="fas fa-copy"></i> SVG 복사
  </button>
  <button id="copy-json-button" class="btn btn-secondary" disabled>
    <i class="fas fa-code"></i> JSON 복사
  </button>
</section>


  <!-- 도움말 버튼 -->
  <button class="help-btn" id="helpBtn" title="도움말">
    <i class="fas fa-question"></i>
  </button>

  <!-- XLSX.js 라이브러리 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- 모듈화된 JavaScript 파일들 -->
 

  <script>
  // 페이지 완전히 로드된 후 실행
  window.addEventListener('load', function() {
    // 요소 참조
    const templateSelector = document.getElementById('template-selector');
    const csvInput = document.getElementById('csv-input');
    const chartTypeSelector = document.getElementById('chart-type-selector');
    const errorContainer = document.getElementById('error-container');
    
    // 템플릿 데이터 (templates 전역 변수가 없는 경우 대비)
    const templateData = {
      'bar-chart': `101,Bar Chart\n102,Business Presentation\n103,Executives\n201,Numerical\n202,Comparison\n301,Vertical\n302,Corporate\n401,분기별 매출 실적\n402,매 분기 꾸준한 성장세를 보이고 있습니다.\n403,Values Only\n501,SVG\n601,["Q1", "Q2", "Q3", "Q4"]\n602,"매출(백만원)"\n701,[120, 150, 130, 180]\n706,160`,
      'pie-chart': `101,Pie Chart\n102,Report\n103,Stakeholders\n201,Categorical\n202,Composition\n301,Single Focus\n302,Vibrant\n401,지역별 매출 비중\n403,Percentage\n501,SVG\n601,["서울", "부산", "인천", "대구", "광주"]\n701,[40, 25, 15, 12, 8]`,
      'line-chart': `101,Line Chart\n102,Business Presentation\n201,Temporal\n202,Trend\n301,Horizontal\n302,Corporate\n401,분기별 매출 추이\n501,SVG\n601,["Q1", "Q2", "Q3", "Q4"]\n602,"매출(백만원)"\n701,[120, 150, 130, 180]`,
      'radar-chart': `101,Radar Chart\n102,Comparison Analysis\n202,Comparison\n301,Single Focus\n302,Brand Colors\n401,제품 성능 비교\n501,SVG\n601,["성능", "가격", "디자인", "내구성", "사용성"]\n602,"점수"\n603,["제품 A", "제품 B"]\n606,["0", "1", "2", "3", "4", "5"]\n701,[4, 3, 5, 4, 3]\n702,[3, 5, 2, 5, 4]`,
      'process-diagram': `101,Process Diagram\n102,Educational\n202,Sequential\n301,Horizontal\n302,Vibrant\n304,Flat Icons\n305,Arrows\n306,Size Variation\n401,5단계 제품 개발 프로세스\n402,아이디어부터 출시까지의 주요 단계\n501,SVG\n504,Sequential Reveal\n601,["아이디어 발굴", "컨셉 개발", "설계", "테스트", "출시"]\n701,["새로운 시장 기회 탐색\\n경쟁사 분석\\n고객 니즈 파악", "제품 컨셉 정의\\n기능 명세\\n시장성 평가", "상세 설계\\n프로토타입 개발\\n생산 계획", "품질 테스트\\n사용자 테스트\\n피드백 수집", "마케팅 캠페인\\n판매 채널 확보\\n고객 지원 준비"]`,
      'comparison-chart': `101,Comparison Chart\n102,Marketing\n201,Numerical\n202,Comparison\n301,Split Screen\n302,Brand Colors\n401,제품 기능 비교\n501,SVG\n601,["크기", "속도", "성능", "가격", "디자인"]\n603,["제품 A", "제품 B"]\n701,[8, 6, 9, 5, 8]\n702,[5, 9, 7, 7, 6]`,
      'timeline': `101,Timeline\n102,Educational\n201,Temporal\n202,Sequential\n301,Horizontal\n302,Cool Tones\n401,프로젝트 타임라인\n501,SVG\n601,["1월", "2월", "3월", "4월", "5월"]\n602,"진행도"\n701,["프로젝트 시작", "요구사항 분석", "디자인 완료", "개발 단계", "출시"]\n702,["초기 계획 및 팀 구성", "사용자 요구사항 수집 및 분석", "UI/UX 디자인 완료", "코어 기능 개발", "제품 출시 및 마케팅"]`
    };
    
    // 템플릿 선택 이벤트 직접 연결
    if (templateSelector && csvInput) {
      templateSelector.addEventListener('change', function() {
        const selectedTemplate = this.value;
        const templateContent = templateData[selectedTemplate];
        
        if (templateContent) {
          // CSV 입력 필드에 템플릿 데이터 적용
          csvInput.value = templateContent;
          
          // 차트 유형 추출 및 변경
          const chartTypeMatch = templateContent.match(/101,(.*)/);
          if (chartTypeMatch && chartTypeSelector) {
            chartTypeSelector.value = chartTypeMatch[1].trim();
          }
          
          // 성공 메시지 표시
          if (errorContainer) {
            errorContainer.innerHTML = '<div class="alert alert-success">템플릿이 적용되었습니다.</div>';
            setTimeout(() => { errorContainer.innerHTML = ''; }, 3000);
          }
        }
      });
    }
  });
</script>

<!-- 디버깅 스크립트 추가 -->

<script>
window.addEventListener('load', function() {
  // ─── 공통 색상 팔레트 함수 (새로 추가) ───
function getColorScheme(key) {
  const palettes = {
    corporate: ['#4285F4', '#34A853', '#FBBC05', '#EA4335', '#5F6368'],
    vibrant:   ['#FF5733', '#33FF57', '#3357FF', '#FF33F5', '#F5FF33'],
    monochromatic: ['#333333', '#555555', '#777777', '#999999', '#BBBBBB']
    // 필요하면 계속 추가
  };
  key = (key || 'corporate').toLowerCase().replace(/\s+/g, '');
  return palettes[key] || palettes['corporate'];
}

  console.log('페이지 로드 완료');
  
  // CSV 파싱 함수 직접 구현
  function parseCSVData(csvText) {
    const result = {
      data: {}
    };
    
    if (!csvText) {
      console.error('CSV 데이터가 비어 있습니다.');
      return result;
    }
    
    const lines = csvText.split(/\r?\n/).filter(line => line.trim());
    
    lines.forEach((line, index) => {
      // 첫 번째 쉼표 위치 찾기
      const firstCommaIndex = line.indexOf(',');
      
      if (firstCommaIndex === -1) {
        console.warn(`라인 ${index + 1}: 쉼표가 없습니다.`);
        return;
      }
      
      // ID와 값 분리
      const id = line.substring(0, firstCommaIndex).trim();
      const value = line.substring(firstCommaIndex + 1).trim();
      
      // 값이 JSON 배열인지 확인 및 파싱
      if (value.startsWith('[') && value.endsWith(']')) {
        try {
          result.data[id] = JSON.parse(value);
        } catch (error) {
          console.error(`JSON 파싱 오류 (ID: ${id}):`, error);
          result.data[id] = value; // 파싱 실패 시 원래 값 사용
        }
      } else {
        // 따옴표로 감싸진 문자열에서 따옴표 제거
        if (value.startsWith('"') && value.endsWith('"')) {
          result.data[id] = value.substring(1, value.length - 1);
        } else {
          result.data[id] = value;
        }
      }
    });
    
    console.log('파싱된 CSV 데이터:', result.data);
    return result;
  }
  
  // 간단한 인포그래픽 렌더링 함수
  function renderSimpleChart(container, data) {
    // 컨테이너 초기화
    container.innerHTML = '';
    
    const visualizationType = data['101'] ? data['101'].toLowerCase() : '';
    const chartTitle = data['401'] || '인포그래픽';
    
    // 간단한 헤더 추가
    const header = document.createElement('h3');
    header.textContent = chartTitle;
    header.style.textAlign = 'center';
    container.appendChild(header);
    
    if (visualizationType.includes('bar chart')) {
      renderSimpleBarChart(container, data);
    } else if (visualizationType.includes('pie chart')) {
      renderSimplePieChart(container, data);
    } else if (visualizationType.includes('line chart')) {
      renderSimpleLineChart(container, data);
    } else if (visualizationType.includes('process diagram')) {
      renderSimpleProcessDiagram(container, data);
    } else if (visualizationType.includes('timeline')) {
      renderSimpleTimeline(container, data);
    } else if (visualizationType.includes('radar chart')) {
      renderSimpleRadarChart(container, data);
    } else if (visualizationType.includes('comparison chart')) {
      renderSimpleComparisonChart(container, data);
    } else {
      container.innerHTML += `
        <div style="text-align:center; color:#e74c3c; padding:30px;">
          <i class="fas fa-exclamation-triangle" style="font-size: 3rem;"></i>
          <p style="margin-top:20px;">차트 유형 "${data['101'] || '지정되지 않음'}"에 대한 렌더링 함수가 준비 중입니다.</p>
        </div>
      `;
    }
  }

// 막대 차트를 SVG로 렌더링 (방향 지원 추가)
function renderSimpleBarChart(container, data) {
  const xLabels = data['601'] || [];
  const dataset = data['701'] || [];
  const chartTitle = data['401'] || '막대 차트';
  const isHorizontal = data['301'] && data['301'].toLowerCase().includes('horizontal');
  
  console.log('바차트 방향:', isHorizontal ? '수평' : '수직');
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 생성
  const svgWidth = 800;
  const svgHeight = 500;
  const paddingX = 60;
  const paddingY = 80;
  const chartWidth = svgWidth - 2 * paddingX;
  const chartHeight = svgHeight - 2 * paddingY;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 최대값 계산
  const maxValue = Math.max(...dataset.map(v => Number(v) || 0));
  const values = dataset.map(v => Number(v) || 0);
  
  if (isHorizontal) {
    // 수평 막대 차트 (바가 왼쪽에서 오른쪽으로)
    
    // Y축 추가 (세로축 - 카테고리)
    const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxis.setAttribute('x1', paddingX);
    yAxis.setAttribute('y1', paddingY);
    yAxis.setAttribute('x2', paddingX);
    yAxis.setAttribute('y2', svgHeight - paddingY);
    yAxis.setAttribute('stroke', '#333');
    yAxis.setAttribute('stroke-width', '2');
    svg.appendChild(yAxis);
    
    // X축 추가 (가로축 - 값)
    const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxis.setAttribute('x1', paddingX);
    xAxis.setAttribute('y1', svgHeight - paddingY);
    xAxis.setAttribute('x2', svgWidth - paddingX);
    xAxis.setAttribute('y2', svgHeight - paddingY);
    xAxis.setAttribute('stroke', '#333');
    xAxis.setAttribute('stroke-width', '2');
    svg.appendChild(xAxis);
    
    // 막대 높이 계산
    const barHeight = chartHeight / xLabels.length / 2;
    const barSpacing = chartHeight / xLabels.length;
    
    // 막대 생성
    for (let i = 0; i < Math.min(xLabels.length, values.length); i++) {
      const value = values[i];
      const width = (value / maxValue) * chartWidth;
      const y = paddingY + i * barSpacing + barHeight / 2;
      const x = paddingX;
      
      // 막대 추가
      const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bar.setAttribute('x', x);
      bar.setAttribute('y', y);
      bar.setAttribute('width', width);
      bar.setAttribute('height', barHeight);
      bar.setAttribute('fill', '#4285F4');
      svg.appendChild(bar);
      
      // 값 라벨 추가
      const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valueText.setAttribute('x', x + width + 10);
      valueText.setAttribute('y', y + barHeight / 2);
      valueText.setAttribute('dominant-baseline', 'middle');
      valueText.setAttribute('font-size', '12');
      valueText.textContent = value;
      svg.appendChild(valueText);
      
      // Y축 라벨 추가 (카테고리)
      const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      labelText.setAttribute('x', paddingX - 10);
      labelText.setAttribute('y', y + barHeight / 2);
      labelText.setAttribute('text-anchor', 'end');
      labelText.setAttribute('dominant-baseline', 'middle');
      labelText.setAttribute('font-size', '12');
      labelText.textContent = xLabels[i];
      svg.appendChild(labelText);
    }
  } else {
    // 수직 막대 차트 (기존 코드)
    
    // X축 추가
    const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxis.setAttribute('x1', paddingX);
    xAxis.setAttribute('y1', svgHeight - paddingY);
    xAxis.setAttribute('x2', svgWidth - paddingX);
    xAxis.setAttribute('y2', svgHeight - paddingY);
    xAxis.setAttribute('stroke', '#333');
    xAxis.setAttribute('stroke-width', '2');
    svg.appendChild(xAxis);
    
    // Y축 추가
    const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxis.setAttribute('x1', paddingX);
    yAxis.setAttribute('y1', paddingY);
    yAxis.setAttribute('x2', paddingX);
    yAxis.setAttribute('y2', svgHeight - paddingY);
    yAxis.setAttribute('stroke', '#333');
    yAxis.setAttribute('stroke-width', '2');
    svg.appendChild(yAxis);
    
    // 막대 너비 계산
    const barWidth = chartWidth / xLabels.length / 2;
    const barSpacing = chartWidth / xLabels.length;
    
    // 막대 생성
    for (let i = 0; i < Math.min(xLabels.length, values.length); i++) {
      const value = values[i];
      const height = (value / maxValue) * chartHeight;
      const x = paddingX + i * barSpacing + barWidth / 2;
      const y = svgHeight - paddingY - height;
      
      // 막대 추가
      const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bar.setAttribute('x', x);
      bar.setAttribute('y', y);
      bar.setAttribute('width', barWidth);
      bar.setAttribute('height', height);
      bar.setAttribute('fill', '#4285F4');
      svg.appendChild(bar);
      
      // 값 라벨 추가
      const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valueText.setAttribute('x', x + barWidth / 2);
      valueText.setAttribute('y', y - 10);
      valueText.setAttribute('text-anchor', 'middle');
      valueText.setAttribute('font-size', '12');
      valueText.textContent = value;
      svg.appendChild(valueText);
      
      // X축 라벨 추가
      const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      labelText.setAttribute('x', x + barWidth / 2);
      labelText.setAttribute('y', svgHeight - paddingY + 20);
      labelText.setAttribute('text-anchor', 'middle');
      labelText.setAttribute('font-size', '12');
      labelText.textContent = xLabels[i];
      svg.appendChild(labelText);
    }
  }
}
  
// 파이 차트를 SVG로 렌더링 (수정 버전)
function renderSimplePieChart(container, data) {
  const labels = data['601'] || [];
  const values = data['701'] || [];
  const chartTitle = data['401'] || '파이 차트';
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정
  const svgWidth = 800;
  const svgHeight = 500;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 고정 색상 배열 (HSL 대신 사용)
 // const colors = [
 //  '#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8334A2',
 // '#1A73E8', '#D93025', '#F9AB00', '#1E8E3E', '#7627BB'
 // ]; 
  const colors = getColorScheme(data['302']);

  // 데이터 합계 및 각도 계산
  const total = values.reduce((sum, val) => sum + (Number(val) || 0), 0);
  
  // 차트 중심점 및 반지름
  const centerX = 250;
  const centerY = 250;
  const radius = 150;
  
  // 파이 조각 생성
  let startAngle = 0;
  
  for (let i = 0; i < values.length; i++) {
    const value = Number(values[i]) || 0;
    const percentage = value / total;
    const endAngle = startAngle + percentage * 2 * Math.PI;
    
    // 파이 조각 경로 계산
    const x1 = centerX + Math.cos(startAngle) * radius;
    const y1 = centerY + Math.sin(startAngle) * radius;
    const x2 = centerX + Math.cos(endAngle) * radius;
    const y2 = centerY + Math.sin(endAngle) * radius;
    
    const largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;
    
    const pathData = `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
    
    // 고정 색상 배열에서 색상 선택
    const color = colors[i % colors.length];
    
    // 파이 조각 생성 (인라인 스타일 추가)
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathData);
    path.setAttribute('fill', color);
    path.setAttribute('stroke', 'white');
    path.setAttribute('stroke-width', '1');
    path.setAttribute('style', `fill: ${color}; fill-opacity: 1;`);
    svg.appendChild(path);
    
    // 텍스트 위치 계산 (조각 중앙)
    const textAngle = startAngle + (endAngle - startAngle) / 2;
    const textRadius = radius * 0.7;
    const textX = centerX + Math.cos(textAngle) * textRadius;
    const textY = centerY + Math.sin(textAngle) * textRadius;
    
    // 퍼센트 텍스트 추가 (조각 안)
    if (percentage > 0.05) { // 5% 이상인 경우만 표시
      const percentText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      percentText.setAttribute('x', textX);
      percentText.setAttribute('y', textY);
      percentText.setAttribute('text-anchor', 'middle');
      percentText.setAttribute('dominant-baseline', 'middle');
      percentText.setAttribute('fill', 'white');
      percentText.setAttribute('font-size', '14');
      percentText.setAttribute('font-weight', 'bold');
      percentText.textContent = `${Math.round(percentage * 100)}%`;
      svg.appendChild(percentText);
    }
    
    // 범례 항목
    const legendY = 120 + i * 30;
    
    // 범례 색상 표시 (인라인 스타일 추가)
    const legendColor = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    legendColor.setAttribute('x', 500);
    legendColor.setAttribute('y', legendY);
    legendColor.setAttribute('width', '20');
    legendColor.setAttribute('height', '20');
    legendColor.setAttribute('fill', color);
    legendColor.setAttribute('style', `fill: ${color}; fill-opacity: 1;`);
    svg.appendChild(legendColor);
    
    // 범례 레이블
    const legendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    legendText.setAttribute('x', 530);
    legendText.setAttribute('y', legendY + 15);
    legendText.setAttribute('font-size', '14');
    legendText.textContent = `${labels[i] || `항목 ${i+1}`}: ${value} (${Math.round(percentage * 100)}%)`;
    svg.appendChild(legendText);
    
    startAngle = endAngle;
  }
}

  //라인차트 렌더링
function renderSimpleLineChart(container, data) {
  const xLabels = data['601'] || [];
  const dataset = data['701'] || [];
  const dataset2 = data['702'] || [];
  const hasSecondDataset = Array.isArray(dataset2) && dataset2.length > 0;
  const seriesLabels = data['603'] || ['시리즈 1', '시리즈 2'];
  const chartTitle = data['401'] || '라인 차트';
  
  // 데이터의 302(색상 스키마) 값을 받아 팔레트 얻기
  const colors = getColorScheme(data['302']);
  const primaryColor   = colors[0] || '#4285F4';   // 첫 번째 시리즈용
  const secondaryColor = colors[1] || '#EA4335';   // 두 번째 시리즈용

  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 생성
  const svgWidth = 800;
  const svgHeight = 400;
  const paddingX = 50;
  const paddingY = 50;
  const chartWidth = svgWidth - 2 * paddingX;
  const chartHeight = svgHeight - 2 * paddingY;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 데이터 값 범위 계산
  const allValues = [...dataset];
  if (hasSecondDataset) allValues.push(...dataset2);
  let minValue = Math.min(...allValues.map(v => Number(v) || 0));
  minValue = Math.floor(minValue * 0.9); // 약간의 여유 공간
  
  let maxValue = Math.max(...allValues.map(v => Number(v) || 0));
  maxValue = Math.ceil(maxValue * 1.1); // 약간의 여유 공간
  
  // 그리드 라인 및 Y축 레이블
  const gridLines = 5;
  for (let i = 0; i <= gridLines; i++) {
    const y = paddingY + chartHeight - (i / gridLines) * chartHeight;
    const value = minValue + (i / gridLines) * (maxValue - minValue);
    
    // 그리드 라인
    const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    gridLine.setAttribute('x1', paddingX);
    gridLine.setAttribute('y1', y);
    gridLine.setAttribute('x2', paddingX + chartWidth);
    gridLine.setAttribute('y2', y);
    gridLine.setAttribute('stroke', '#e0e0e0');
    gridLine.setAttribute('stroke-width', '1');
    svg.appendChild(gridLine);
    
    // Y축 레이블
    const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yLabel.setAttribute('x', paddingX - 10);
    yLabel.setAttribute('y', y);
    yLabel.setAttribute('text-anchor', 'end');
    yLabel.setAttribute('alignment-baseline', 'middle');
    yLabel.setAttribute('font-size', '12');
    yLabel.textContent = Math.round(value);
    svg.appendChild(yLabel);
  }
  
  // X축 라인
  const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  xAxis.setAttribute('x1', paddingX);
  xAxis.setAttribute('y1', paddingY + chartHeight);
  xAxis.setAttribute('x2', paddingX + chartWidth);
  xAxis.setAttribute('y2', paddingY + chartHeight);
  xAxis.setAttribute('stroke', '#333');
  xAxis.setAttribute('stroke-width', '1');
  svg.appendChild(xAxis);
  
  // X축 레이블
  const xStep = chartWidth / (xLabels.length - 1 || 1);
  xLabels.forEach((label, i) => {
    const x = paddingX + i * xStep;
    const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    xLabel.setAttribute('x', x);
    xLabel.setAttribute('y', paddingY + chartHeight + 20);
    xLabel.setAttribute('text-anchor', 'middle');
    xLabel.setAttribute('font-size', '12');
    xLabel.textContent = label;
    svg.appendChild(xLabel);
  });
  
  // 첫 번째 데이터셋 라인
  const linePath1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  let path1Data = '';
  
  dataset.forEach((value, i) => {
    if (i >= xLabels.length) return;
    
    const x = paddingX + i * xStep;
    const yValue = Number(value) || 0;
    const normalizedValue = (yValue - minValue) / (maxValue - minValue);
    const y = paddingY + chartHeight - (normalizedValue * chartHeight);
    
    path1Data += `${i === 0 ? 'M' : 'L'} ${x} ${y} `;
  });
  
  linePath1.setAttribute('d', path1Data);
  linePath1.setAttribute('fill', 'none');
  linePath1.setAttribute('stroke', primaryColor);
  linePath1.setAttribute('stroke-width', '2');
  linePath1.setAttribute('style', `stroke: ${primaryColor}; stroke-opacity: 1;`);
  svg.appendChild(linePath1);
  
  // 첫 번째 데이터셋 포인트
  dataset.forEach((value, i) => {
    if (i >= xLabels.length) return;
    
    const x = paddingX + i * xStep;
    const yValue = Number(value) || 0;
    const normalizedValue = (yValue - minValue) / (maxValue - minValue);
    const y = paddingY + chartHeight - (normalizedValue * chartHeight);
    
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', '4');
    circle.setAttribute('fill', primaryColor);
    circle.setAttribute('style', `fill: ${primaryColor}; fill-opacity: 1;`);
    svg.appendChild(circle);
    
    const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    valueText.setAttribute('x', x);
    valueText.setAttribute('y', y - 10);
    valueText.setAttribute('text-anchor', 'middle');
    valueText.setAttribute('font-size', '10');
    valueText.textContent = value;
    svg.appendChild(valueText);
  });
  
  // 두 번째 데이터셋 (있을 경우)
  if (hasSecondDataset) {
    const linePath2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let path2Data = '';
    
    dataset2.forEach((value, i) => {
      if (i >= xLabels.length) return;
      
      const x = paddingX + i * xStep;
      const yValue = Number(value) || 0;
      const normalizedValue = (yValue - minValue) / (maxValue - minValue);
      const y = paddingY + chartHeight - (normalizedValue * chartHeight);
      
      path2Data += `${i === 0 ? 'M' : 'L'} ${x} ${y} `;
    });
    
    linePath2.setAttribute('d', path2Data);
    linePath2.setAttribute('fill', 'none');
    linePath2.setAttribute('stroke', secondaryColor);
    linePath2.setAttribute('stroke-width', '2');
    linePath2.setAttribute('style', `stroke: ${secondaryColor}; stroke-opacity: 1;`);
    svg.appendChild(linePath2);
    
    // 두 번째 데이터셋 포인트
    dataset2.forEach((value, i) => {
      if (i >= xLabels.length) return;
      
      const x = paddingX + i * xStep;
      const yValue = Number(value) || 0;
      const normalizedValue = (yValue - minValue) / (maxValue - minValue);
      const y = paddingY + chartHeight - (normalizedValue * chartHeight);
      
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', x);
      circle.setAttribute('cy', y);
      circle.setAttribute('r', '4');
      circle.setAttribute('fill', secondaryColor);
      circle.setAttribute('style', `fill: ${secondaryColor}; fill-opacity: 1;`);
      svg.appendChild(circle);
      
      const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valueText.setAttribute('x', x);
      valueText.setAttribute('y', y - 10);
      valueText.setAttribute('text-anchor', 'middle');
      valueText.setAttribute('font-size', '10');
      valueText.textContent = value;
      svg.appendChild(valueText);
    });
  }
  
  // 범례
  const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  legendGroup.setAttribute('transform', `translate(${svgWidth - 200}, 40)`);
  
  // 첫 번째 시리즈 범례
  const legendLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  legendLine1.setAttribute('x1', 0);
  legendLine1.setAttribute('y1', 0);
  legendLine1.setAttribute('x2', 30);
  legendLine1.setAttribute('y2', 0);
  legendLine1.setAttribute('stroke', primaryColor);
  legendLine1.setAttribute('stroke-width', '2');
  legendGroup.appendChild(legendLine1);
  
  const legendCircle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  legendCircle1.setAttribute('cx', 15);
  legendCircle1.setAttribute('cy', 0);
  legendCircle1.setAttribute('r', '3');
  legendCircle1.setAttribute('fill', primaryColor);
  legendGroup.appendChild(legendCircle1);
  
  const legendText1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  legendText1.setAttribute('x', 40);
  legendText1.setAttribute('y', 5);
  legendText1.setAttribute('font-size', '12');
  legendText1.textContent = seriesLabels[0];
  legendGroup.appendChild(legendText1);
  
  if (hasSecondDataset) {
    // 두 번째 시리즈 범례
    const legendLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    legendLine2.setAttribute('x1', 100);
    legendLine2.setAttribute('y1', 0);
    legendLine2.setAttribute('x2', 130);
    legendLine2.setAttribute('y2', 0);
    legendLine2.setAttribute('stroke', secondaryColor);
    legendLine2.setAttribute('stroke-width', '2');
    legendGroup.appendChild(legendLine2);
    
    const legendCircle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    legendCircle2.setAttribute('cx', 115);
    legendCircle2.setAttribute('cy', 0);
    legendCircle2.setAttribute('r', '3');
    legendCircle2.setAttribute('fill', secondaryColor);
    legendGroup.appendChild(legendCircle2);
    
    const legendText2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    legendText2.setAttribute('x', 140);
    legendText2.setAttribute('y', 5);
    legendText2.setAttribute('font-size', '12');
    legendText2.textContent = seriesLabels[1];
    legendGroup.appendChild(legendText2);
  }
  
  svg.appendChild(legendGroup);
}

  // 비교 차트를 SVG로 렌더링
function renderSimpleComparisonChart(container, data) {
  const labels = data['601'] || [];   // 예: ['크기','속도','성능',…]
  const valuesA = data['701'] || [];   // 첫 번째 제품 값 배열
  const valuesB = data['702'] || [];   // 두 번째 제품 값 배열
  const series = data['603'] || ['A','B'];
  const chartTitle = data['401'] || '비교 차트';
  const maxValue = Math.max(
    ...valuesA.map(v=>+v||0),
    ...valuesB.map(v=>+v||0)
  );

  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정
  const svgWidth = 800;
  const svgHeight = 500;
  const paddingX = 60;
  const paddingY = 80;
  const chartWidth = svgWidth - 2 * paddingX;
  const chartHeight = svgHeight - 2 * paddingY;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // X축 추가
  const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  xAxis.setAttribute('x1', paddingX);
  xAxis.setAttribute('y1', svgHeight - paddingY);
  xAxis.setAttribute('x2', svgWidth - paddingX);
  xAxis.setAttribute('y2', svgHeight - paddingY);
  xAxis.setAttribute('stroke', '#333');
  xAxis.setAttribute('stroke-width', '1');
  svg.appendChild(xAxis);
  
  // 막대 너비 및 간격 계산
  const groupWidth = chartWidth / labels.length;
  const barWidth = groupWidth / 3;
  const barSpacing = barWidth / 2;
  
  // 각 그룹의 막대 생성
  for (let i = 0; i < labels.length; i++) {
    const x = paddingX + i * groupWidth + groupWidth / 4;
    
    // 첫 번째 막대 (A)
    const valueA = +valuesA[i] || 0;
    const heightA = (valueA / maxValue) * chartHeight;
    const barA = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    barA.setAttribute('x', x);
    barA.setAttribute('y', svgHeight - paddingY - heightA);
    barA.setAttribute('width', barWidth);
    barA.setAttribute('height', heightA);
    barA.setAttribute('fill', '#4285F4');
    svg.appendChild(barA);
    
    // 첫 번째 막대 값 라벨
    const labelA = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    labelA.setAttribute('x', x + barWidth / 2);
    labelA.setAttribute('y', svgHeight - paddingY - heightA - 5);
    labelA.setAttribute('text-anchor', 'middle');
    labelA.setAttribute('font-size', '12');
    labelA.textContent = valueA;
    svg.appendChild(labelA);
    
    // 두 번째 막대 (B)
    const valueB = +valuesB[i] || 0;
    const heightB = (valueB / maxValue) * chartHeight;
    const barB = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    barB.setAttribute('x', x + barWidth + barSpacing);
    barB.setAttribute('y', svgHeight - paddingY - heightB);
    barB.setAttribute('width', barWidth);
    barB.setAttribute('height', heightB);
    barB.setAttribute('fill', '#EA4335');
    svg.appendChild(barB);
    
    // 두 번째 막대 값 라벨
    const labelB = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    labelB.setAttribute('x', x + barWidth * 1.5 + barSpacing);
    labelB.setAttribute('y', svgHeight - paddingY - heightB - 5);
    labelB.setAttribute('text-anchor', 'middle');
    labelB.setAttribute('font-size', '12');
    labelB.textContent = valueB;
    svg.appendChild(labelB);
    
    // X축 라벨
    const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    xLabel.setAttribute('x', x + barWidth + barSpacing / 2);
    xLabel.setAttribute('y', svgHeight - paddingY + 20);
    xLabel.setAttribute('text-anchor', 'middle');
    xLabel.setAttribute('font-size', '12');
    xLabel.textContent = labels[i];
    svg.appendChild(xLabel);
  }
  
  // 범례 추가
  // 범례 상자
  const legendBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  legendBox.setAttribute('x', svgWidth - 150);
  legendBox.setAttribute('y', 50);
  legendBox.setAttribute('width', 120);
  legendBox.setAttribute('height', 50);
  legendBox.setAttribute('fill', 'white');
  legendBox.setAttribute('stroke', '#ddd');
  legendBox.setAttribute('stroke-width', '1');
  svg.appendChild(legendBox);
  
  // 첫 번째 시리즈 범례
  const legendA = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  legendA.setAttribute('x', svgWidth - 140);
  legendA.setAttribute('y', 60);
  legendA.setAttribute('width', 15);
  legendA.setAttribute('height', 15);
  legendA.setAttribute('fill', '#4285F4');
  svg.appendChild(legendA);
  
  const legendTextA = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  legendTextA.setAttribute('x', svgWidth - 120);
  legendTextA.setAttribute('y', 72);
  legendTextA.setAttribute('font-size', '12');
  legendTextA.textContent = series[0];
  svg.appendChild(legendTextA);
  
  // 두 번째 시리즈 범례
  const legendB = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  legendB.setAttribute('x', svgWidth - 140);
  legendB.setAttribute('y', 80);
  legendB.setAttribute('width', 15);
  legendB.setAttribute('height', 15);
  legendB.setAttribute('fill', '#EA4335');
  svg.appendChild(legendB);
  
  const legendTextB = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  legendTextB.setAttribute('x', svgWidth - 120);
  legendTextB.setAttribute('y', 92);
  legendTextB.setAttribute('font-size', '12');
  legendTextB.textContent = series[1];
  svg.appendChild(legendTextB);
}
  
 // 프로세스 다이어그램을 SVG로 렌더링
function renderSimpleProcessDiagram(container, data) {
  const steps = data['601'] || [];
  const descriptions = data['701'] || [];
  const isHorizontal = data['301'] && data['301'].toLowerCase().includes('horizontal');
  const chartTitle = data['401'] || '프로세스 다이어그램';
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정 (가로형/세로형에 따라 다르게)
  const svgWidth = isHorizontal ? 900 : 600;
  const svgHeight = isHorizontal ? 400 : Math.max(400, steps.length * 120);
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 색상 계산 함수
  function getColor(index) {
    const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8334A2'];
    return colors[index % colors.length];
  }
  
  if (isHorizontal) {
    // 수평 프로세스 다이어그램
    const boxWidth = 120;
    const boxHeight = 80;
    const arrowLength = 40;
    const startY = 100;
    
    for (let i = 0; i < steps.length; i++) {
      const x = 60 + i * (boxWidth + arrowLength);
      const color = getColor(i);
      
      // 프로세스 박스
      const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      box.setAttribute('x', x);
      box.setAttribute('y', startY);
      box.setAttribute('width', boxWidth);
      box.setAttribute('height', boxHeight);
      box.setAttribute('rx', '6');
      box.setAttribute('ry', '6');
      box.setAttribute('fill', color);
      svg.appendChild(box);
      
      // 단계 텍스트
      const stepText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      stepText.setAttribute('x', x + boxWidth / 2);
      stepText.setAttribute('y', startY + boxHeight / 2);
      stepText.setAttribute('text-anchor', 'middle');
      stepText.setAttribute('dominant-baseline', 'middle');
      stepText.setAttribute('fill', 'white');
      stepText.setAttribute('font-size', '14');
      stepText.setAttribute('font-weight', 'bold');
      stepText.textContent = steps[i];
      svg.appendChild(stepText);
      
      // 설명 텍스트 (줄바꿈 처리)
      if (descriptions[i]) {
        const descLines = descriptions[i].split('\\n');
        const lineHeight = 16;
        
        for (let j = 0; j < descLines.length; j++) {
          const descText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          descText.setAttribute('x', x + boxWidth / 2);
          descText.setAttribute('y', startY + boxHeight + 20 + j * lineHeight);
          descText.setAttribute('text-anchor', 'middle');
          descText.setAttribute('font-size', '12');
          descText.textContent = descLines[j];
          svg.appendChild(descText);
        }
      }
      
      // 화살표 (마지막 항목 제외)
      if (i < steps.length - 1) {
        const arrowX = x + boxWidth;
        const arrowY = startY + boxHeight / 2;
        
        // 화살표 선
        const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        arrowLine.setAttribute('x1', arrowX);
        arrowLine.setAttribute('y1', arrowY);
        arrowLine.setAttribute('x2', arrowX + arrowLength);
        arrowLine.setAttribute('y2', arrowY);
        arrowLine.setAttribute('stroke', '#666');
        arrowLine.setAttribute('stroke-width', '2');
        svg.appendChild(arrowLine);
        
        // 화살표 머리
        const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        arrowHead.setAttribute('d', `M ${arrowX + arrowLength - 10} ${arrowY - 6} L ${arrowX + arrowLength} ${arrowY} L ${arrowX + arrowLength - 10} ${arrowY + 6}`);
        arrowHead.setAttribute('fill', 'none');
        arrowHead.setAttribute('stroke', '#666');
        arrowHead.setAttribute('stroke-width', '2');
        svg.appendChild(arrowHead);
      }
    }
  } else {
    // 수직 프로세스 다이어그램
    const boxWidth = 300;
    const boxHeight = 80;
    const arrowLength = 40;
    const startX = (svgWidth - boxWidth) / 2;
    
    for (let i = 0; i < steps.length; i++) {
      const y = 80 + i * (boxHeight + arrowLength);
      const color = getColor(i);
      
      // 프로세스 박스
      const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      box.setAttribute('x', startX);
      box.setAttribute('y', y);
      box.setAttribute('width', boxWidth);
      box.setAttribute('height', boxHeight);
      box.setAttribute('rx', '6');
      box.setAttribute('ry', '6');
      box.setAttribute('fill', color);
      svg.appendChild(box);
      
      // 단계 텍스트
      const stepText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      stepText.setAttribute('x', startX + boxWidth / 2);
      stepText.setAttribute('y', y + 25);
      stepText.setAttribute('text-anchor', 'middle');
      stepText.setAttribute('fill', 'white');
      stepText.setAttribute('font-size', '14');
      stepText.setAttribute('font-weight', 'bold');
      stepText.textContent = steps[i];
      svg.appendChild(stepText);
      
      // 설명 텍스트 (줄바꿈 처리)
      if (descriptions[i]) {
        const descLines = descriptions[i].split('\\n');
        const lineHeight = 16;
        
        for (let j = 0; j < descLines.length; j++) {
          if (j < 3) { // 최대 3줄로 제한
            const descText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            descText.setAttribute('x', startX + boxWidth / 2);
            descText.setAttribute('y', y + 45 + j * lineHeight);
            descText.setAttribute('text-anchor', 'middle');
            descText.setAttribute('fill', 'white');
            descText.setAttribute('font-size', '12');
            descText.textContent = descLines[j];
            svg.appendChild(descText);
          }
        }
      }
      
      // 화살표 (마지막 항목 제외)
      if (i < steps.length - 1) {
        const arrowX = startX + boxWidth / 2;
        const arrowY = y + boxHeight;
        
        // 화살표 선
        const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        arrowLine.setAttribute('x1', arrowX);
        arrowLine.setAttribute('y1', arrowY);
        arrowLine.setAttribute('x2', arrowX);
        arrowLine.setAttribute('y2', arrowY + arrowLength);
        arrowLine.setAttribute('stroke', '#666');
        arrowLine.setAttribute('stroke-width', '2');
        svg.appendChild(arrowLine);
        
        // 화살표 머리
        const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        arrowHead.setAttribute('d', `M ${arrowX - 6} ${arrowY + arrowLength - 10} L ${arrowX} ${arrowY + arrowLength} L ${arrowX + 6} ${arrowY + arrowLength - 10}`);
        arrowHead.setAttribute('fill', 'none');
        arrowHead.setAttribute('stroke', '#666');
        arrowHead.setAttribute('stroke-width', '2');
        svg.appendChild(arrowHead);
      }
    }
  }
}

 // 타임라인을 SVG로 렌더링
function renderSimpleTimeline(container, data) {
  const events = data['601'] || [];
  const titles = data['701'] || [];
  const descriptions = data['702'] || [];
  const isVertical = data['301'] && data['301'].toLowerCase().includes('vertical');
  const chartTitle = data['401'] || '타임라인';
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정
  const svgWidth = isVertical ? 700 : Math.max(800, events.length * 150);
  const svgHeight = isVertical ? Math.max(400, events.length * 120) : 500;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 색상 계산 함수
  function getColor(index) {
    const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8334A2'];
    return colors[index % colors.length];
  }
  
  if (isVertical) {
    // 수직 타임라인
    const centerX = 150;
    const startY = 80;
    const itemHeight = 100;
    
    // 중앙 선
    const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    centerLine.setAttribute('x1', centerX);
    centerLine.setAttribute('y1', startY);
    centerLine.setAttribute('x2', centerX);
    centerLine.setAttribute('y2', startY + itemHeight * events.length);
    centerLine.setAttribute('stroke', '#ddd');
    centerLine.setAttribute('stroke-width', '4');
    svg.appendChild(centerLine);
    
    for (let i = 0; i < events.length; i++) {
      const y = startY + i * itemHeight;
      const color = getColor(i);
      const isRight = i % 2 === 0; // 왼쪽/오른쪽 번갈아가며 배치
      
      // 이벤트 원
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', centerX);
      circle.setAttribute('cy', y + 20);
      circle.setAttribute('r', '10');
      circle.setAttribute('fill', color);
      svg.appendChild(circle);
      
      // 이벤트 날짜/시간
      const timeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      timeText.setAttribute('x', isRight ? centerX - 20 : centerX + 20);
      timeText.setAttribute('y', y + 25);
      timeText.setAttribute('text-anchor', isRight ? 'end' : 'start');
      timeText.setAttribute('font-size', '14');
      timeText.setAttribute('font-weight', 'bold');
      timeText.textContent = events[i];
      svg.appendChild(timeText);
      
      // 이벤트 내용 박스
      const boxWidth = 250;
      const boxHeight = 70;
      const boxX = isRight ? centerX + 30 : centerX - 30 - boxWidth;
      
      const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      box.setAttribute('x', boxX);
      box.setAttribute('y', y - 10);
      box.setAttribute('width', boxWidth);
      box.setAttribute('height', boxHeight);
      box.setAttribute('rx', '5');
      box.setAttribute('fill', '#f8f9fa');
      box.setAttribute('stroke', color);
      box.setAttribute('stroke-width', '2');
      svg.appendChild(box);
      
      // 이벤트 제목
      const titleText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      titleText.setAttribute('x', boxX + 10);
      titleText.setAttribute('y', y + 15);
      titleText.setAttribute('font-size', '14');
      titleText.setAttribute('font-weight', 'bold');
      titleText.setAttribute('fill', color);
      titleText.textContent = titles[i] || '';
      svg.appendChild(titleText);
      
      // 이벤트 설명
      if (descriptions[i]) {
        const descText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        descText.setAttribute('x', boxX + 10);
        descText.setAttribute('y', y + 40);
        descText.setAttribute('font-size', '12');
        
        // 설명 텍스트 (글자수 제한)
        let desc = descriptions[i];
        if (desc.length > 60) {
          desc = desc.substring(0, 57) + '...';
        }
        descText.textContent = desc;
        svg.appendChild(descText);
      }
      
      // 연결선
      const connectorStartX = isRight ? centerX + 10 : centerX - 10;
      const connectorEndX = isRight ? boxX : boxX + boxWidth;
      
      const connector = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      connector.setAttribute('x1', connectorStartX);
      connector.setAttribute('y1', y + 20);
      connector.setAttribute('x2', connectorEndX);
      connector.setAttribute('y2', y + 20);
      connector.setAttribute('stroke', color);
      connector.setAttribute('stroke-width', '2');
      svg.appendChild(connector);
    }
  } else {
    // 수평 타임라인
    const centerY = 180;
    const startX = 80;
    const itemWidth = (svgWidth - 160) / events.length;
    
    // 중앙 선
    const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    centerLine.setAttribute('x1', startX);
    centerLine.setAttribute('y1', centerY);
    centerLine.setAttribute('x2', svgWidth - 80);
    centerLine.setAttribute('y2', centerY);
    centerLine.setAttribute('stroke', '#ddd');
    centerLine.setAttribute('stroke-width', '4');
    svg.appendChild(centerLine);
    
    for (let i = 0; i < events.length; i++) {
      const x = startX + i * itemWidth;
      const color = getColor(i);
      const isTop = i % 2 === 0; // 위/아래 번갈아가며 배치
      
      // 이벤트 원
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', x + itemWidth / 2);
      circle.setAttribute('cy', centerY);
      circle.setAttribute('r', '10');
      circle.setAttribute('fill', color);
      svg.appendChild(circle);
      
      // 이벤트 날짜/시간
      const timeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      timeText.setAttribute('x', x + itemWidth / 2);
      timeText.setAttribute('y', isTop ? centerY + 30 : centerY - 15);
      timeText.setAttribute('text-anchor', 'middle');
      timeText.setAttribute('font-size', '14');
      timeText.setAttribute('font-weight', 'bold');
      timeText.textContent = events[i];
      svg.appendChild(timeText);
      
      // 이벤트 내용 박스
      const boxWidth = itemWidth - 20;
      const boxHeight = 70;
      const boxY = isTop ? centerY - boxHeight - 20 : centerY + 20;
      
      const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      box.setAttribute('x', x + 10);
      box.setAttribute('y', boxY);
      box.setAttribute('width', boxWidth);
      box.setAttribute('height', boxHeight);
      box.setAttribute('rx', '5');
      box.setAttribute('fill', '#f8f9fa');
      box.setAttribute('stroke', color);
      box.setAttribute('stroke-width', '2');
      svg.appendChild(box);
      
      // 이벤트 제목
      const titleText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      titleText.setAttribute('x', x + itemWidth / 2);
      titleText.setAttribute('y', boxY + 20);
      titleText.setAttribute('text-anchor', 'middle');
      titleText.setAttribute('font-size', '14');
      titleText.setAttribute('font-weight', 'bold');
      titleText.setAttribute('fill', color);
      titleText.textContent = titles[i] || '';
      svg.appendChild(titleText);
      
      // 이벤트 설명
      if (descriptions[i]) {
        const descText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        descText.setAttribute('x', x + itemWidth / 2);
        descText.setAttribute('y', boxY + 45);
        descText.setAttribute('text-anchor', 'middle');
        descText.setAttribute('font-size', '12');
        
        // 설명 텍스트 (글자수 제한)
        let desc = descriptions[i];
        if (desc.length > 30) {
          desc = desc.substring(0, 27) + '...';
        }
        descText.textContent = desc;
        svg.appendChild(descText);
      }
      
      // 연결선
      const connectorStartY = isTop ? centerY - 10 : centerY + 10;
      const connectorEndY = isTop ? boxY + boxHeight : boxY;
      
      const connector = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      connector.setAttribute('x1', x + itemWidth / 2);
      connector.setAttribute('y1', connectorStartY);
      connector.setAttribute('x2', x + itemWidth / 2);
      connector.setAttribute('y2', connectorEndY);
      connector.setAttribute('stroke', color);
      connector.setAttribute('stroke-width', '2');
      svg.appendChild(connector);
    }
  }
}
  
  // 간단한 레이더 차트 렌더링
function renderSimpleRadarChart(container, data) {
  const labels = data['601'] || [];
  const dataset1 = data['701'] || [];
  const dataset2 = data['702'] || [];
  const hasSecondDataset = Array.isArray(dataset2) && dataset2.length > 0;
  const seriesLabels = data['603'] || ['시리즈 1', '시리즈 2'];
  const chartTitle = data['401'] || '레이더 차트';

  // 최대값 계산
  const allValues = [...dataset1];
  if (hasSecondDataset) allValues.push(...dataset2);
  const maxValue = Math.max(...allValues.map(v => Number(v) || 0));
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정
  const svgWidth = 800;
  const svgHeight = 500;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 중심점과 반지름
  const centerX = svgWidth / 2;
  const centerY = svgHeight / 2;
  const radius = Math.min(svgWidth, svgHeight) * 0.35;
  const numPoints = labels.length;
  const angleStep = (Math.PI * 2) / numPoints;
  
  // 배경 그리드 그리기
  const levels = 5;
  for (let i = 1; i <= levels; i++) {
    const gridRadius = (radius * i) / levels;
    let pathData = "";
    
    for (let j = 0; j < numPoints; j++) {
      const angle = -Math.PI/2 + j * angleStep;
      const x = centerX + gridRadius * Math.cos(angle);
      const y = centerY + gridRadius * Math.sin(angle);
      
      if (j === 0) {
        pathData += `M ${x} ${y} `;
      } else {
        pathData += `L ${x} ${y} `;
      }
    }
    pathData += "Z";
    
    const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    gridPath.setAttribute('d', pathData);
    gridPath.setAttribute('fill', 'none');
    gridPath.setAttribute('stroke', '#ddd');
    gridPath.setAttribute('stroke-width', '1');
    svg.appendChild(gridPath);
    
    // 값 표시 (선택적)
    if (i === levels) {
      for (let j = 0; j < numPoints; j++) {
        const angle = -Math.PI/2 + j * angleStep;
        const labelValue = i;
        
        // 값 위치 조정
        const textX = centerX + (gridRadius + 15) * Math.cos(angle);
        const textY = centerY + (gridRadius + 15) * Math.sin(angle);
        
        const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        valueLabel.setAttribute('x', textX);
        valueLabel.setAttribute('y', textY);
        valueLabel.setAttribute('text-anchor', 'middle');
        valueLabel.setAttribute('font-size', '10');
        valueLabel.setAttribute('fill', '#999');
        valueLabel.textContent = labelValue;
        svg.appendChild(valueLabel);
      }
    }
  }
  
  // 축 그리기
  for (let i = 0; i < numPoints; i++) {
    const angle = -Math.PI/2 + i * angleStep;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    
    const axisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    axisLine.setAttribute('x1', centerX);
    axisLine.setAttribute('y1', centerY);
    axisLine.setAttribute('x2', x);
    axisLine.setAttribute('y2', y);
    axisLine.setAttribute('stroke', '#ddd');
    axisLine.setAttribute('stroke-width', '1');
    svg.appendChild(axisLine);
    
    // 레이블 위치 계산 및 그리기
    const labelDistance = radius + 25; // 레이블과 차트 사이 간격 늘림
    const labelX = centerX + labelDistance * Math.cos(angle);
    const labelY = centerY + labelDistance * Math.sin(angle);
    
    const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    labelText.setAttribute('x', labelX);
    labelText.setAttribute('y', labelY);
    labelText.setAttribute('text-anchor', 'middle');
    labelText.setAttribute('dominant-baseline', 'middle');
    labelText.setAttribute('font-size', '12');
    labelText.textContent = labels[i] || `항목 ${i+1}`;
    svg.appendChild(labelText);
  }
  
  // 첫 번째 데이터셋 폴리곤 그리기
  drawDataPolygon(dataset1, "#4285F4", 0.6);
  
  // 두 번째 데이터셋이 있으면 그리기
  if (hasSecondDataset) {
    drawDataPolygon(dataset2, "#EA4335", 0.6);
  }
  
  // 범례 추가
  const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  legendGroup.setAttribute('transform', `translate(${centerX - 100}, ${centerY + radius + 40})`);
  
  // 첫 번째 데이터셋 범례
  const legendRect1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  legendRect1.setAttribute('x', '0');
  legendRect1.setAttribute('y', '0');
  legendRect1.setAttribute('width', '15');
  legendRect1.setAttribute('height', '15');
  legendRect1.setAttribute('fill', '#4285F4');
  legendRect1.setAttribute('fill-opacity', '0.6');
  legendRect1.setAttribute('style', 'fill: #4285F4; fill-opacity: 0.6;');
  legendGroup.appendChild(legendRect1);
  
  const legendText1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  legendText1.setAttribute('x', '25');
  legendText1.setAttribute('y', '12');
  legendText1.setAttribute('font-size', '12');
  legendText1.textContent = seriesLabels[0] || "시리즈 1";
  legendGroup.appendChild(legendText1);
  
  if (hasSecondDataset) {
    // 두 번째 데이터셋 범례
    const legendRect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    legendRect2.setAttribute('x', '100');
    legendRect2.setAttribute('y', '0');
    legendRect2.setAttribute('width', '15');
    legendRect2.setAttribute('height', '15');
    legendRect2.setAttribute('fill', '#EA4335');
    legendRect2.setAttribute('fill-opacity', '0.6');
    legendRect2.setAttribute('style', 'fill: #EA4335; fill-opacity: 0.6;');
    legendGroup.appendChild(legendRect2);
    
    const legendText2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    legendText2.setAttribute('x', '125');
    legendText2.setAttribute('y', '12');
    legendText2.setAttribute('font-size', '12');
    legendText2.textContent = seriesLabels[1] || "시리즈 2";
    legendGroup.appendChild(legendText2);
  }
  
  svg.appendChild(legendGroup);
  
  // 데이터 폴리곤 그리기 함수
  function drawDataPolygon(dataset, color, opacity) {
    // 폴리곤 경로 생성
    let polygonPath = "";
    
    for (let i = 0; i < numPoints; i++) {
      const value = i < dataset.length ? Number(dataset[i]) || 0 : 0;
      const ratio = Math.min(value / maxValue, 1);
      const angle = -Math.PI/2 + i * angleStep;
      const x = centerX + radius * ratio * Math.cos(angle);
      const y = centerY + radius * ratio * Math.sin(angle);
      
      if (i === 0) {
        polygonPath += `M ${x} ${y} `;
      } else {
        polygonPath += `L ${x} ${y} `;
      }
    }
    
    polygonPath += "Z"; // 경로 닫기
    
    // 폴리곤 추가
    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    polygon.setAttribute('d', polygonPath);
    polygon.setAttribute('fill', color);
    polygon.setAttribute('fill-opacity', String(opacity));
    polygon.setAttribute('stroke', color);
    polygon.setAttribute('stroke-width', '2');
    polygon.setAttribute('style', `fill: ${color}; fill-opacity: ${opacity}; stroke: ${color};`);
    svg.appendChild(polygon);
    
    // 데이터 포인트와 값 추가
    for (let i = 0; i < numPoints; i++) {
      const value = i < dataset.length ? Number(dataset[i]) || 0 : 0;
      const ratio = Math.min(value / maxValue, 1);
      const angle = -Math.PI/2 + i * angleStep;
      const x = centerX + radius * ratio * Math.cos(angle);
      const y = centerY + radius * ratio * Math.sin(angle);
      
      // 데이터 포인트
      const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      dot.setAttribute('cx', String(x));
      dot.setAttribute('cy', String(y));
      dot.setAttribute('r', '4');
      dot.setAttribute('fill', color);
      dot.setAttribute('style', `fill: ${color};`);
      svg.appendChild(dot);
      
      // 값 라벨
      const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valueText.setAttribute('x', String(x));
      valueText.setAttribute('y', String(y - 10));
      valueText.setAttribute('text-anchor', 'middle');
      valueText.setAttribute('font-size', '11');
      valueText.setAttribute('fill', color);
      valueText.setAttribute('font-weight', 'bold');
      valueText.textContent = value;
      svg.appendChild(valueText);
    }
  }
}
  
 // 인포그래픽 생성 버튼에 이벤트 리스너 연결
  document.getElementById('generate-button').addEventListener('click', function() {
    console.log('인포그래픽 생성 버튼 클릭됨');
    
    try {
      // CSV 데이터 가져오기
      const csvInput = document.getElementById('csv-input');
      const csvText = csvInput.value;
      console.log('CSV 데이터:', csvText); // CSV 내용 확인
      
      // CSV 파싱
      const parseResult = parseCSVData(csvText);
      const data = parseResult.data;
      
      // 레이아웃 값 확인 로그 추가
      console.log('레이아웃 설정:', data['301']);
      console.log('시각화 유형:', data['101']);
      
      // 미리보기 컨테이너 가져오기
      const previewContainer = document.getElementById('preview-container');
      
      // 기존 내용 제거 (메모리 누수 방지)
      previewContainer.innerHTML = '';
      
      // 인포그래픽 렌더링
      renderSimpleChart(previewContainer, data);
      
      // 다운로드 버튼 활성화
      const downloadButton = document.getElementById('download-button');
      if (downloadButton) {
        downloadButton.disabled = false;
      }
    } catch (error) {
      console.error('인포그래픽 생성 중 오류:', error);
      
      // 오류 메시지 표시
      const errorContainer = document.getElementById('error-container');
      if (errorContainer) {
        errorContainer.innerHTML = `<div class="alert alert-danger">인포그래픽 생성 중 오류가 발생했습니다: ${error.message}</div>`;
      }
    }
  });
});
// “초기화” 버튼 클릭 시 동작
document.getElementById('clear-button').addEventListener('click', function() {
  // 1) CSV 입력란 비우기
  document.getElementById('csv-input').value = '';
  // 2) 미리보기 기본 안내로 리셋
  document.getElementById('preview-container').innerHTML = `
    <div style="text-align: center; color: #6b7280;">
      <i class="fas fa-chart-bar" style="font-size: 3rem; margin-bottom: 1rem;"></i>
      <p>인포그래픽을 생성하려면 CSV 데이터를 입력하고 '인포그래픽 생성' 버튼을 클릭하세요.</p>
    </div>
  `;
  // 3) 다운로드 버튼 비활성화
  const dl = document.getElementById('download-button');
  if (dl) dl.disabled = true;
});

// "SVG 다운로드" 버튼 클릭 시 동작
// "SVG 다운로드" 버튼 클릭 시 동작
document.getElementById('download-button').addEventListener('click', function() {
  const previewContainer = document.getElementById('preview-container');
  
  // SVG 요소 찾기
  let svg = previewContainer.querySelector('svg');
  
  if (!svg) {
    alert('다운로드할 SVG가 없습니다. 다른 차트 유형을 선택해보세요.');
    return;
  }
  
  // SVG 복제 (원본 변경 방지)
  let clonedSvg = svg.cloneNode(true);
  
  // SVG에 인라인 스타일 추가 (더 명시적인 스타일)
  let styles = `
    <defs>
      <style>
        text { font-family: Arial, sans-serif; fill: #000000; }
        path { stroke-linecap: round; stroke-linejoin: round; }
        rect { stroke-linecap: round; stroke-linejoin: round; }
        circle { stroke-linecap: round; stroke-linejoin: round; }
        line { stroke-linecap: round; stroke-linejoin: round; }
      </style>
    </defs>
  `;
  
  // 모든 투명도 속성을 명시적으로 설정
  // 경로(path) 요소 처리 (레이더 차트, 파이 차트 등)
  const pathElements = clonedSvg.querySelectorAll('path');
  pathElements.forEach(el => {
    const fillColor = el.getAttribute('fill');
    if (fillColor && fillColor !== 'none') {
      // 기존 투명도 값 가져오기 (없으면 기본값 사용)
      let opacity = el.getAttribute('fill-opacity') || '1';
      
      // 레이더 차트 폴리곤 여부 확인 (투명도가 필요한지 판단)
      if (el.hasAttribute('stroke') && el.getAttribute('stroke-width') === '2') {
        // 레이더 차트 폴리곤으로 추정
        opacity = '0.6';
      }
      
      // 인라인 스타일과 속성 모두 설정
      el.setAttribute('fill', fillColor);
      el.setAttribute('fill-opacity', opacity);
      el.setAttribute('style', `fill: ${fillColor}; fill-opacity: ${opacity};`);
    }
    
    // 선 색상도 처리
    const strokeColor = el.getAttribute('stroke');
    if (strokeColor && strokeColor !== 'none') {
      el.setAttribute('style', (el.getAttribute('style') || '') + ` stroke: ${strokeColor};`);
    }
  });
  
  // 사각형(rect) 요소 처리 (범례 등)
  const rectElements = clonedSvg.querySelectorAll('rect');
  rectElements.forEach(el => {
    const fillColor = el.getAttribute('fill');
    if (fillColor && fillColor !== 'none') {
      // 기존 투명도 값 가져오기 (없으면 기본값 사용)
      let opacity = el.getAttribute('fill-opacity') || '1';
      
      // 레이더 차트 범례 여부 확인
      if (opacity !== '1' || el.getAttribute('width') === '15' && el.getAttribute('height') === '15') {
        // 범례로 추정, 투명도 명시적 설정
        opacity = opacity || '0.6';
      }
      
      // 인라인 스타일과 속성 모두 설정
      el.setAttribute('fill', fillColor);
      el.setAttribute('fill-opacity', opacity);
      el.setAttribute('style', `fill: ${fillColor}; fill-opacity: ${opacity};`);
    }
  });
  
  // 네임스페이스 설정 (중요)
  clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  clonedSvg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  
  // viewBox 확인 및 설정
  if (!clonedSvg.getAttribute('viewBox')) {
    const width = clonedSvg.getAttribute('width') || '800';
    const height = clonedSvg.getAttribute('height') || '600';
    clonedSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  }
  
  // 스타일 삽입
  clonedSvg.innerHTML = styles + clonedSvg.innerHTML;
  
  // SVG 문자열로 직렬화
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(clonedSvg);
  
  // Blob 생성
  const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  
  // 가상의 a 태그로 다운로드 트리거
  const a = document.createElement('a');
  a.href = url;
  a.download = 'infographic.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

</script>
  
</body>
</html>
