<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>인포그래픽 포토리 프레임워크</title>
  <link rel="stylesheet" href="styles.css">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome 아이콘 사용을 위한 CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
  <div class="container">
    <header class="header">
      <h1>인포그래픽 프레임워크</h1>
      <p>CSV 데이터를 구조화된 인포그래픽으로 변환하는 도구</p>
    </header>

    <!-- 탭 네비게이션 -->
    <ul class="nav nav-tabs mb-3" id="inputTabs" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="csv-tab" data-bs-toggle="tab" data-bs-target="#csv-panel" type="button" role="tab" aria-controls="csv-panel" aria-selected="true">
          <i class="fas fa-file-csv me-1"></i> CSV 입력
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="spreadsheet-tab" data-bs-toggle="tab" data-bs-target="#spreadsheet-panel" type="button" role="tab" aria-controls="spreadsheet-panel" aria-selected="false">
          <i class="fas fa-table me-1"></i> 스프레드시트
        </button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="upload-tab" data-bs-toggle="tab" data-bs-target="#upload-panel" type="button" role="tab" aria-controls="upload-panel" aria-selected="false">
          <i class="fas fa-upload me-1"></i> 파일 업로드
        </button>
      </li>
    </ul>

    <div class="tab-content" id="inputTabsContent">
      <!-- CSV 입력 패널 -->
      <div class="tab-pane fade show active" id="csv-panel" role="tabpanel" aria-labelledby="csv-tab">
        <div class="panel">
          <div class="panel-header" id="csvInputHeader">
            <h2><i class="fas fa-table icon"></i> CSV 데이터 입력</h2>
            <i class="fas fa-chevron-down toggle-icon"></i>
          </div>
          <div class="panel-body" id="csvInputBody">
            <div class="csv-input">
              <textarea id="csv-input" placeholder="3자리 ID와 키워드를 쉼표로 구분하여 입력하세요. 각 항목은 새 줄에 입력합니다.&#10;&#10;예: 101,Bar Chart&#10;102,Business Presentation&#10;301,Vertical&#10;302,Corporate"></textarea>
              <p>각 항목은 3자리 ID와 쉼표, 그리고 키워드로 구성됩니다.</p>
            </div>
            <div class="btn-group">
              <button class="btn btn-primary" id="generate-button">
                <i class="fas fa-magic icon"></i> 인포그래픽 생성
              </button>
              <button class="btn btn-secondary" id="parseCSVBtn">
                <i class="fas fa-file-csv icon"></i> CSV 파싱
              </button>
            </div>

           <div class="toolbar-section mt-3">
            <div class="card mb-3">
              <div class="card-header bg-light">
                <h3 class="mb-0"><i class="fas fa-magic me-2"></i>인포그래픽 예제 보기</h3>
              </div>
              <div class="card-body">
                <p class="text-muted">템플릿을 선택하여 인포그래픽 예제를 확인할 수 있습니다.</p>
                <select id="template-selector" class="form-select mb-3">
                  <option value="bar-chart">막대 차트</option>
                  <option value="pie-chart">파이 차트</option>
                  <option value="line-chart">선 그래프</option>
                  <option value="radar-chart">레이더 차트</option>
                  <option value="process-diagram">프로세스 다이어그램</option>
                  <option value="comparison-chart">비교 차트</option>
                  <option value="timeline">타임라인</option>
                </select>
              </div>
            </div>
            
            <h3>차트 속성 변경:</h3>
            <div class="row mt-3">
              <div class="col-md-6">
                <label for="chart-type-selector" class="form-label">차트 유형:</label>
                  <select id="chart-type-selector" class="form-select mb-2">
                    <option value="Bar Chart">막대 차트</option>
                    <option value="Pie Chart">파이 차트</option>
                    <option value="Line Chart">선 그래프</option>
                    <option value="Radar Chart">레이더 차트</option>
                    <option value="Process Diagram">프로세스 다이어그램</option>
                    <option value="Timeline">타임라인</option>
                  </select>
                </div>
                <div class="col-md-6">
                  <label for="color-scheme-selector" class="form-label">색상 스키마:</label>
                  <select id="color-scheme-selector" class="form-select mb-2">
                    <option value="Corporate">Corporate</option>
                    <option value="Vibrant">Vibrant</option>
                    <option value="Monochromatic">Monochromatic</option>
                    <option value="Cool Tones">Cool Tones</option>
                    <option value="Warm Tones">Warm Tones</option>
                    <option value="Brand Colors">Brand Colors</option>
                    <option value="High Contrast">High Contrast</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- 스프레드시트 패널 -->
      <div class="tab-pane fade" id="spreadsheet-panel" role="tabpanel" aria-labelledby="spreadsheet-tab">
        <div class="panel">
          <div class="panel-header">
            <h2><i class="fas fa-table icon"></i> 스프레드시트 데이터 입력</h2>
            <i class="fas fa-chevron-down toggle-icon"></i>
          </div>
          <div class="panel-body">
            <div id="spreadsheet-container"></div>
            <div class="d-flex mt-3 gap-2">
              <button id="data-to-chart-btn" class="btn btn-primary">
                <i class="fas fa-chart-bar me-1"></i> 인포그래픽 데이터로 변환
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- 파일 업로드 패널 -->
      <div class="tab-pane fade" id="upload-panel" role="tabpanel" aria-labelledby="upload-tab">
        <div class="panel">
          <div class="panel-header">
            <h2><i class="fas fa-upload icon"></i> 파일 업로드</h2>
            <i class="fas fa-chevron-down toggle-icon"></i>
          </div>
          <div class="panel-body">
            <div class="mb-3">
              <label for="file-upload" class="form-label">CSV 또는 Excel 파일 업로드</label>
              <input class="form-control" type="file" id="file-upload" accept=".csv,.xlsx,.xls">
              <div class="form-text">CSV 또는 Excel 파일을 업로드하면 자동으로 데이터를 처리합니다.</div>
            </div>
            <div id="upload-preview" class="mt-3">
              <!-- 업로드된 파일 미리보기가 여기에 표시됩니다 -->
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 프레임워크 데이터 패널 -->
    <div class="panel">
      <div class="panel-header" id="frameworkDataHeader">
        <h2><i class="fas fa-layer-group icon"></i> 프레임워크 데이터</h2>
        <i class="fas fa-chevron-down toggle-icon"></i>
      </div>
      <div class="panel-body" id="frameworkDataBody">
        <div class="framework-data">
          <!-- 데이터는 JavaScript로 채워집니다 -->
          <div class="data-item">
            <h3>메타 레이어 (100번대)</h3>
            <div class="data-value" id="metaLayerData">데이터가 없습니다.</div>
          </div>
          <div class="data-item">
            <h3>데이터 레이어 (200번대)</h3>
            <div class="data-value" id="dataLayerData">데이터가 없습니다.</div>
          </div>
          <div class="data-item">
            <h3>디자인 레이어 (300번대)</h3>
            <div class="data-value" id="designLayerData">데이터가 없습니다.</div>
          </div>
          <div class="data-item">
            <h3>콘텐츠 레이어 (400번대)</h3>
            <div class="data-value" id="contentLayerData">데이터가 없습니다.</div>
          </div>
          <div class="data-item">
            <h3>기술 레이어 (500번대)</h3>
            <div class="data-value" id="techLayerData">데이터가 없습니다.</div>
          </div>
          <div class="data-item">
            <h3>데이터 레이블 레이어 (600번대)</h3>
            <div class="data-value" id="dataLabelLayerData">데이터가 없습니다.</div>
          </div>
          <div class="data-item">
            <h3>데이터 값 레이어 (700번대)</h3>
            <div class="data-value" id="dataValueLayerData">데이터가 없습니다.</div>
          </div>
        </div>
      </div>
    </div>

    <!-- 인포그래픽 미리보기 -->
    <div class="preview-container">
      <div class="preview-header">
        <h2><i class="fas fa-eye"></i> 인포그래픽 미리보기</h2>
      </div>
      <div id="error-container"></div>
      <div class="preview-content" id="preview-container">
        <!-- 인포그래픽이 여기에 렌더링됩니다 -->
        <div style="text-align: center; color: #6b7280;">
          <i class="fas fa-chart-bar" style="font-size: 3rem; margin-bottom: 1rem;"></i>
          <p>인포그래픽을 생성하려면 CSV 데이터를 입력하고 '인포그래픽 생성' 버튼을 클릭하세요.<BR>ⓒ PHOTORY</BR></p>
        </div>
      </div>
      <div class="preview-info" id="previewInfo" style="display: none;">
        <h3>인포그래픽 정보</h3>
        <ul id="infographicDetails">
          <!-- 인포그래픽 세부 정보가 여기에 표시됩니다 -->
        </ul>
      </div>
      <div class="export-buttons mt-3">
        <button class="btn btn-primary" id="download-button" disabled>
          <i class="fas fa-download icon"></i> SVG 다운로드
        </button>
        <button class="btn btn-secondary" id="copy-svg-button">
          <i class="fas fa-copy icon"></i> SVG 코드 복사
        </button>
        <button class="btn btn-secondary" id="copy-json-button">
          <i class="fas fa-code icon"></i> JSON 데이터 복사
        </button>
      </div>
    </div>
  </div>

  <!-- 도움말 버튼 -->
  <button class="help-btn" id="helpBtn" title="도움말">
    <i class="fas fa-question"></i>
  </button>

  <!-- XLSX.js 라이브러리 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- 모듈화된 JavaScript 파일들 -->
 

  <script>
  // 페이지 완전히 로드된 후 실행
  window.addEventListener('load', function() {
    // 요소 참조
    const templateSelector = document.getElementById('template-selector');
    const csvInput = document.getElementById('csv-input');
    const chartTypeSelector = document.getElementById('chart-type-selector');
    const errorContainer = document.getElementById('error-container');
    
    // 템플릿 데이터 (templates 전역 변수가 없는 경우 대비)
    const templateData = {
      'bar-chart': `101,Bar Chart\n102,Business Presentation\n103,Executives\n201,Numerical\n202,Comparison\n301,Vertical\n302,Corporate\n401,분기별 매출 실적\n402,매 분기 꾸준한 성장세를 보이고 있습니다.\n403,Values Only\n501,SVG\n601,["Q1", "Q2", "Q3", "Q4"]\n602,"매출(백만원)"\n701,[120, 150, 130, 180]\n706,160`,
      'pie-chart': `101,Pie Chart\n102,Report\n103,Stakeholders\n201,Categorical\n202,Composition\n301,Single Focus\n302,Vibrant\n401,지역별 매출 비중\n403,Percentage\n501,SVG\n601,["서울", "부산", "인천", "대구", "광주"]\n701,[40, 25, 15, 12, 8]`,
      'line-chart': `101,Line Chart\n102,Business Presentation\n201,Temporal\n202,Trend\n301,Horizontal\n302,Corporate\n401,분기별 매출 추이\n501,SVG\n601,["Q1", "Q2", "Q3", "Q4"]\n602,"매출(백만원)"\n701,[120, 150, 130, 180]`,
      'radar-chart': `101,Radar Chart\n102,Comparison Analysis\n202,Comparison\n301,Single Focus\n302,Brand Colors\n401,제품 성능 비교\n501,SVG\n601,["성능", "가격", "디자인", "내구성", "사용성"]\n602,"점수"\n603,["제품 A", "제품 B"]\n606,["0", "1", "2", "3", "4", "5"]\n701,[4, 3, 5, 4, 3]\n702,[3, 5, 2, 5, 4]`,
      'process-diagram': `101,Process Diagram\n102,Educational\n202,Sequential\n301,Horizontal\n302,Vibrant\n304,Flat Icons\n305,Arrows\n306,Size Variation\n401,5단계 제품 개발 프로세스\n402,아이디어부터 출시까지의 주요 단계\n501,SVG\n504,Sequential Reveal\n601,["아이디어 발굴", "컨셉 개발", "설계", "테스트", "출시"]\n701,["새로운 시장 기회 탐색\\n경쟁사 분석\\n고객 니즈 파악", "제품 컨셉 정의\\n기능 명세\\n시장성 평가", "상세 설계\\n프로토타입 개발\\n생산 계획", "품질 테스트\\n사용자 테스트\\n피드백 수집", "마케팅 캠페인\\n판매 채널 확보\\n고객 지원 준비"]`,
      'comparison-chart': `101,Comparison Chart\n102,Marketing\n201,Numerical\n202,Comparison\n301,Split Screen\n302,Brand Colors\n401,제품 기능 비교\n501,SVG\n601,["크기", "속도", "성능", "가격", "디자인"]\n603,["제품 A", "제품 B"]\n701,[8, 6, 9, 5, 8]\n702,[5, 9, 7, 7, 6]`,
      'timeline': `101,Timeline\n102,Educational\n201,Temporal\n202,Sequential\n301,Horizontal\n302,Cool Tones\n401,프로젝트 타임라인\n501,SVG\n601,["1월", "2월", "3월", "4월", "5월"]\n602,"진행도"\n701,["프로젝트 시작", "요구사항 분석", "디자인 완료", "개발 단계", "출시"]\n702,["초기 계획 및 팀 구성", "사용자 요구사항 수집 및 분석", "UI/UX 디자인 완료", "코어 기능 개발", "제품 출시 및 마케팅"]`
    };
    
    // 템플릿 선택 이벤트 직접 연결
    if (templateSelector && csvInput) {
      templateSelector.addEventListener('change', function() {
        const selectedTemplate = this.value;
        const templateContent = templateData[selectedTemplate];
        
        if (templateContent) {
          // CSV 입력 필드에 템플릿 데이터 적용
          csvInput.value = templateContent;
          
          // 차트 유형 추출 및 변경
          const chartTypeMatch = templateContent.match(/101,(.*)/);
          if (chartTypeMatch && chartTypeSelector) {
            chartTypeSelector.value = chartTypeMatch[1].trim();
          }
          
          // 성공 메시지 표시
          if (errorContainer) {
            errorContainer.innerHTML = '<div class="alert alert-success">템플릿이 적용되었습니다.</div>';
            setTimeout(() => { errorContainer.innerHTML = ''; }, 3000);
          }
        }
      });
    }
  });
</script>

<!-- 디버깅 스크립트 추가 -->

<script>
window.addEventListener('load', function() {
  console.log('페이지 로드 완료');
  
  // CSV 파싱 함수 직접 구현
  function parseCSVData(csvText) {
    const result = {
      data: {}
    };
    
    if (!csvText) {
      console.error('CSV 데이터가 비어 있습니다.');
      return result;
    }
    
    const lines = csvText.split(/\r?\n/).filter(line => line.trim());
    
    lines.forEach((line, index) => {
      // 첫 번째 쉼표 위치 찾기
      const firstCommaIndex = line.indexOf(',');
      
      if (firstCommaIndex === -1) {
        console.warn(`라인 ${index + 1}: 쉼표가 없습니다.`);
        return;
      }
      
      // ID와 값 분리
      const id = line.substring(0, firstCommaIndex).trim();
      const value = line.substring(firstCommaIndex + 1).trim();
      
      // 값이 JSON 배열인지 확인 및 파싱
      if (value.startsWith('[') && value.endsWith(']')) {
        try {
          result.data[id] = JSON.parse(value);
        } catch (error) {
          console.error(`JSON 파싱 오류 (ID: ${id}):`, error);
          result.data[id] = value; // 파싱 실패 시 원래 값 사용
        }
      } else {
        // 따옴표로 감싸진 문자열에서 따옴표 제거
        if (value.startsWith('"') && value.endsWith('"')) {
          result.data[id] = value.substring(1, value.length - 1);
        } else {
          result.data[id] = value;
        }
      }
    });
    
    console.log('파싱된 CSV 데이터:', result.data);
    return result;
  }
  
  // 간단한 인포그래픽 렌더링 함수
  function renderSimpleChart(container, data) {
    // 컨테이너 초기화
    container.innerHTML = '';
    
    const visualizationType = data['101'] ? data['101'].toLowerCase() : '';
    const chartTitle = data['401'] || '인포그래픽';
    
    // 간단한 헤더 추가
    const header = document.createElement('h3');
    header.textContent = chartTitle;
    header.style.textAlign = 'center';
    container.appendChild(header);
    
    if (visualizationType.includes('bar chart')) {
      renderSimpleBarChart(container, data);
    } else if (visualizationType.includes('pie chart')) {
      renderSimplePieChart(container, data);
    } else if (visualizationType.includes('line chart')) {
      renderSimpleLineChart(container, data);
    } else if (visualizationType.includes('process diagram')) {
      renderSimpleProcessDiagram(container, data);
    } else if (visualizationType.includes('timeline')) {
      renderSimpleTimeline(container, data);
    } else if (visualizationType.includes('radar chart')) {
      renderSimpleRadarChart(container, data);
    } else {
      container.innerHTML += `
        <div style="text-align:center; color:#e74c3c; padding:30px;">
          <i class="fas fa-exclamation-triangle" style="font-size: 3rem;"></i>
          <p style="margin-top:20px;">차트 유형 "${data['101'] || '지정되지 않음'}"에 대한 렌더링 함수가 준비 중입니다.</p>
        </div>
      `;
    }
  }

  // 간단한 막대 차트 렌더링
  function renderSimpleBarChart(container, data) {
  const xLabels = data['601'] || [];
  const dataset = data['701'] || [];
  
  // 간단한 막대 차트 컨테이너 생성
  const chartDiv = document.createElement('div');
  chartDiv.style.width = '100%';
  chartDiv.style.height = '400px';
  chartDiv.style.padding = '20px';
  container.appendChild(chartDiv);
  
  // 차트 HTML 생성
  let chartHTML = `
    <div style="height: 350px; display: flex; align-items: flex-end; justify-content: space-around; padding-bottom: 40px; border-bottom: 1px solid #ddd; border-left: 1px solid #ddd; position: relative;">
  `;
  
  // 최대값 계산
  const maxValue = Math.max(...dataset.map(v => Number(v) || 0));
  const values = dataset.map(v => Number(v) || 0);
  
  // 막대 생성
  for (let i = 0; i < Math.min(xLabels.length, values.length); i++) {
    const value = values[i];
    const height = Math.round((value / maxValue) * 300); // 최대 높이 300px
    
    chartHTML += `
      <div style="display: flex; flex-direction: column; align-items: center; width: ${100 / xLabels.length}%;">
        <div style="height: ${height}px; width: 40px; background-color: #4285F4; margin-bottom: 5px; position: relative; text-align: center;">
          <div style="position: absolute; top: -25px; width: 100%; text-align: center;">${value}</div>
        </div>
        <div>${xLabels[i]}</div>
      </div>
    `;
  }
  
  chartHTML += '</div>';
  chartDiv.innerHTML = chartHTML;
}
  
  // 간단한 파이 차트 렌더링
  function renderSimplePieChart(container, data) {
  const labels = data['601'] || [];
  const values = data['701'] || [];
  
  // 차트 컨테이너 생성
  const chartDiv = document.createElement('div');
  chartDiv.style.width = '100%';
  chartDiv.style.padding = '20px';
  container.appendChild(chartDiv);
  
  // 데이터 합계 및 각도 계산
  const total = values.reduce((sum, val) => sum + (Number(val) || 0), 0);
  
  // 파이 차트 SVG 생성
  let svgHTML = `
    <div style="display: flex; flex-wrap: wrap;">
      <div style="width: 50%; min-width: 300px;">
        <svg width="100%" height="300" viewBox="0 0 300 300">
          <g transform="translate(150, 150)">
  `;
  
  // 파이 조각 생성
  let startAngle = 0;
  for (let i = 0; i < values.length; i++) {
    const value = Number(values[i]) || 0;
    const percentage = value / total;
    const endAngle = startAngle + percentage * 2 * Math.PI;
    
    // 파이 조각 경로 계산
    const x1 = Math.cos(startAngle) * 100;
    const y1 = Math.sin(startAngle) * 100;
    const x2 = Math.cos(endAngle) * 100;
    const y2 = Math.sin(endAngle) * 100;
    
    const largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;
    
    const pathData = `M 0 0 L ${x1} ${y1} A 100 100 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
    
    // 색상 계산
    const hue = (i * 30) % 360;
    
    svgHTML += `
      <path d="${pathData}" fill="hsl(${hue}, 70%, 60%)" stroke="white" stroke-width="1"></path>
    `;
    
    startAngle = endAngle;
  }
  
  svgHTML += `
          </g>
        </svg>
      </div>
      <div style="width: 50%; min-width: 300px; padding: 20px;">
        <div style="display: flex; flex-direction: column; gap: 10px;">
  `;
  
  // 범례 생성
  for (let i = 0; i < Math.min(labels.length, values.length); i++) {
    const value = Number(values[i]) || 0;
    const percentage = (value / total) * 100;
    const hue = (i * 30) % 360;
    
    svgHTML += `
      <div style="display: flex; align-items: center; gap: 10px;">
        <div style="width: 20px; height: 20px; background-color: hsl(${hue}, 70%, 60%);"></div>
        <div>${labels[i]}: ${value} (${percentage.toFixed(1)}%)</div>
      </div>
    `;
  }
  
  svgHTML += `
        </div>
      </div>
    </div>
  `;
  
  chartDiv.innerHTML = svgHTML;
}

function renderSimpleLineChart(container, data) {
  const xLabels = data['601'] || [];
  const dataset = data['701'] || [];
  const dataset2 = data['702'] || [];
  const hasSecondDataset = Array.isArray(dataset2) && dataset2.length > 0;
  const seriesLabels = data['603'] || ['시리즈 1', '시리즈 2'];
  
  // 차트 컨테이너 생성
  const chartDiv = document.createElement('div');
  chartDiv.style.width = '100%';
  chartDiv.style.padding = '20px';
  container.appendChild(chartDiv);
  
  // 데이터 값 범위 계산
  const allValues = [...dataset];
  if (hasSecondDataset) allValues.push(...dataset2);
  let minValue = Math.min(...allValues.map(v => Number(v) || 0));
  minValue = Math.floor(minValue * 0.9); // 약간의 여유 공간
  
  let maxValue = Math.max(...allValues.map(v => Number(v) || 0));
  maxValue = Math.ceil(maxValue * 1.1); // 약간의 여유 공간
  
  // SVG 생성
  const svgWidth = 800;
  const svgHeight = 400;
  const paddingX = 50;
  const paddingY = 50;
  const chartWidth = svgWidth - 2 * paddingX;
  const chartHeight = svgHeight - 2 * paddingY;
  
  let svgHTML = `
    <svg width="100%" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}">
  `;
  
  // 그리드 라인 및 Y축 레이블
  const gridLines = 5;
  for (let i = 0; i <= gridLines; i++) {
    const y = paddingY + chartHeight - (i / gridLines) * chartHeight;
    const value = minValue + (i / gridLines) * (maxValue - minValue);
    
    // 그리드 라인
    svgHTML += `
      <line x1="${paddingX}" y1="${y}" x2="${paddingX + chartWidth}" y2="${y}" 
            stroke="#e0e0e0" stroke-width="1" />
      
      <!-- Y축 레이블 -->
      <text x="${paddingX - 10}" y="${y}" text-anchor="end" alignment-baseline="middle" 
            font-size="12">${Math.round(value)}</text>
    `;
  }
  
  // X축 라인
  svgHTML += `
    <line x1="${paddingX}" y1="${paddingY + chartHeight}" 
          x2="${paddingX + chartWidth}" y2="${paddingY + chartHeight}" 
          stroke="#333" stroke-width="1" />
  `;
  
  // X축 레이블
  const xStep = chartWidth / (xLabels.length - 1);
  xLabels.forEach((label, i) => {
    const x = paddingX + i * xStep;
    svgHTML += `
      <text x="${x}" y="${paddingY + chartHeight + 20}" 
            text-anchor="middle" font-size="12">${label}</text>
    `;
  });
  
  // 첫 번째 데이터셋 라인
  let linePath = `M `;
  dataset.forEach((value, i) => {
    if (i >= xLabels.length) return;
    
    const x = paddingX + i * xStep;
    const yValue = Number(value) || 0;
    const normalizedValue = (yValue - minValue) / (maxValue - minValue);
    const y = paddingY + chartHeight - (normalizedValue * chartHeight);
    
    linePath += `${i === 0 ? '' : 'L '}${x} ${y} `;
  });
  
  svgHTML += `
    <path d="${linePath}" fill="none" stroke="#4285F4" stroke-width="2" />
  `;
  
  // 첫 번째 데이터셋 포인트
  dataset.forEach((value, i) => {
    if (i >= xLabels.length) return;
    
    const x = paddingX + i * xStep;
    const yValue = Number(value) || 0;
    const normalizedValue = (yValue - minValue) / (maxValue - minValue);
    const y = paddingY + chartHeight - (normalizedValue * chartHeight);
    
    svgHTML += `
      <circle cx="${x}" cy="${y}" r="4" fill="#4285F4" />
      <text x="${x}" y="${y - 10}" text-anchor="middle" font-size="10">${value}</text>
    `;
  });
  
  // 두 번째 데이터셋 (있을 경우)
  if (hasSecondDataset) {
    let linePath2 = `M `;
    dataset2.forEach((value, i) => {
      if (i >= xLabels.length) return;
      
      const x = paddingX + i * xStep;
      const yValue = Number(value) || 0;
      const normalizedValue = (yValue - minValue) / (maxValue - minValue);
      const y = paddingY + chartHeight - (normalizedValue * chartHeight);
      
      linePath2 += `${i === 0 ? '' : 'L '}${x} ${y} `;
    });
    
    svgHTML += `
      <path d="${linePath2}" fill="none" stroke="#EA4335" stroke-width="2" />
    `;
    
    // 두 번째 데이터셋 포인트
    dataset2.forEach((value, i) => {
      if (i >= xLabels.length) return;
      
      const x = paddingX + i * xStep;
      const yValue = Number(value) || 0;
      const normalizedValue = (yValue - minValue) / (maxValue - minValue);
      const y = paddingY + chartHeight - (normalizedValue * chartHeight);
      
      svgHTML += `
        <circle cx="${x}" cy="${y}" r="4" fill="#EA4335" />
        <text x="${x}" y="${y - 10}" text-anchor="middle" font-size="10">${value}</text>
      `;
    });
  }
  
  // 범례
  if (hasSecondDataset) {
    const legendY = 30;
    svgHTML += `
      <!-- 첫 번째 시리즈 범례 -->
      <line x1="${svgWidth - 200}" y1="${legendY}" x2="${svgWidth - 170}" y2="${legendY}" 
            stroke="#4285F4" stroke-width="2" />
      <circle cx="${svgWidth - 185}" cy="${legendY}" r="3" fill="#4285F4" />
      <text x="${svgWidth - 160}" y="${legendY + 5}" font-size="12">${seriesLabels[0]}</text>
      
      <!-- 두 번째 시리즈 범례 -->
      <line x1="${svgWidth - 100}" y1="${legendY}" x2="${svgWidth - 70}" y2="${legendY}" 
            stroke="#EA4335" stroke-width="2" />
      <circle cx="${svgWidth - 85}" cy="${legendY}" r="3" fill="#EA4335" />
      <text x="${svgWidth - 60}" y="${legendY + 5}" font-size="12">${seriesLabels[1]}</text>
    `;
  } else {
    svgHTML += `
      <!-- 단일 시리즈 범례 -->
      <line x1="${svgWidth - 150}" y1="30" x2="${svgWidth - 120}" y2="30" 
            stroke="#4285F4" stroke-width="2" />
      <circle cx="${svgWidth - 135}" cy="30" r="3" fill="#4285F4" />
      <text x="${svgWidth - 110}" y="35" font-size="12">${seriesLabels[0]}</text>
    `;
  }
  
  svgHTML += '</svg>';
  chartDiv.innerHTML = svgHTML;
}

  // 프로세스 다이어그램
  function renderSimpleProcessDiagram(container, data) {
  const steps = data['601'] || [];
  const descriptions = data['701'] || [];
  const isHorizontal = data['301'] && data['301'].toLowerCase().includes('horizontal');
  
  // 차트 컨테이너 생성
  const chartDiv = document.createElement('div');
  chartDiv.style.width = '100%';
  chartDiv.style.padding = '20px';
  container.appendChild(chartDiv);
  
  // 색상 계산 함수
  function getColor(index) {
    const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8334A2'];
    return colors[index % colors.length];
  }
  
  if (isHorizontal) {
    // 수평 프로세스 다이어그램
    let html = '<div style="display: flex; flex-direction: row; align-items: center; overflow-x: auto; padding: 20px;">';
    
    steps.forEach((step, index) => {
      const description = descriptions[index] || '';
      const desc = description.split('\\n').join('<br>');
      const color = getColor(index);
      
      html += `
        <div style="flex: 1; min-width: 140px; display: flex; flex-direction: column; align-items: center;">
          <div style="width: 120px; height: 80px; background-color: ${color}; border-radius: 6px; color: white; display: flex; justify-content: center; align-items: center; text-align: center; padding: 10px;">
            <div>${step}</div>
          </div>
          <div style="width: 120px; margin-top: 8px; font-size: 12px; text-align: center;">${desc}</div>
        </div>
      `;
      
      // 화살표 (마지막 항목에는 추가하지 않음)
      if (index < steps.length - 1) {
        html += `
          <div style="width: 40px; text-align: center;">
            <div style="font-size: 24px; color: #666;">→</div>
          </div>
        `;
      }
    });
    
    html += '</div>';
    chartDiv.innerHTML = html;
  } else {
    // 수직 프로세스 다이어그램
    let html = '<div style="display: flex; flex-direction: column; align-items: center; padding: 20px;">';
    
    steps.forEach((step, index) => {
      const description = descriptions[index] || '';
      const desc = description.split('\\n').join('<br>');
      const color = getColor(index);
      
      html += `
        <div style="width: 80%; max-width: 400px; margin-bottom: 10px;">
          <div style="background-color: ${color}; border-radius: 6px; color: white; padding: 15px; text-align: center;">
            <div style="font-weight: bold; margin-bottom: 5px;">${step}</div>
            <div style="font-size: 12px;">${desc}</div>
          </div>
        </div>
      `;
      
      // 화살표 (마지막 항목에는 추가하지 않음)
      if (index < steps.length - 1) {
        html += `
          <div style="height: 30px; text-align: center; margin: 5px 0;">
            <div style="font-size: 24px; color: #666;">↓</div>
          </div>
        `;
      }
    });
    
    html += '</div>';
    chartDiv.innerHTML = html;
  }
}

  // 타임라인
  function renderSimpleTimeline(container, data) {
  const events = data['601'] || [];
  const titles = data['701'] || [];
  const descriptions = data['702'] || [];
  const isVertical = data['301'] && data['301'].toLowerCase().includes('vertical');
  
  // 차트 컨테이너 생성
  const chartDiv = document.createElement('div');
  chartDiv.style.width = '100%';
  chartDiv.style.padding = '20px';
  container.appendChild(chartDiv);
  
  // 색상 계산 함수
  function getColor(index) {
    const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8334A2'];
    return colors[index % colors.length];
  }
  
  if (isVertical) {
    // 수직 타임라인
    let html = '<div style="display: flex; flex-direction: column; margin: 20px; position: relative;">';
    
    // 중앙 선
    html += '<div style="position: absolute; left: 120px; top: 0; bottom: 0; width: 4px; background-color: #ddd;"></div>';
    
    events.forEach((event, index) => {
      const title = titles[index] || '';
      const description = descriptions[index] || '';
      const color = getColor(index);
      
      html += `
        <div style="display: flex; margin-bottom: 30px; position: relative; z-index: 1;">
          <div style="width: 120px; padding-right: 20px; text-align: right; font-weight: bold;">
            ${event}
          </div>
          <div style="width: 20px; height: 20px; border-radius: 50%; background-color: ${color}; margin: 0 10px; z-index: 2;"></div>
          <div style="flex: 1; background-color: #f8f9fa; border-radius: 8px; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
            <div style="font-weight: bold; margin-bottom: 5px; color: ${color};">${title}</div>
            <div style="font-size: 14px;">${description}</div>
          </div>
        </div>
      `;
    });
    
    html += '</div>';
    chartDiv.innerHTML = html;
  } else {
    // 수평 타임라인
    let html = '<div style="padding: 20px; position: relative;">';
    
    // 중앙 선
    html += '<div style="position: absolute; left: 0; right: 0; top: 100px; height: 4px; background-color: #ddd;"></div>';
    
    // 이벤트 컨테이너
    html += '<div style="display: flex; justify-content: space-between; position: relative; z-index: 1;">';
    
    events.forEach((event, index) => {
      const title = titles[index] || '';
      const description = descriptions[index] || '';
      const color = getColor(index);
      const isEven = index % 2 === 0;
      
      // 홀수/짝수 이벤트 위치 조정하여 겹침 방지
      const topMargin = isEven ? '80px' : '30px';
      const bottomMargin = isEven ? '30px' : '80px';
      
      html += `
      <div style="flex: 1; max-width: ${100/events.length}%; min-width: 100px; display: flex; flex-direction: column; align-items: center;">
        <div style="margin-bottom: ${isEven ? '80px' : '30px'}; text-align: center; ${isEven ? '' : 'margin-top: 80px'}">
          <div style="font-weight: bold; color: ${color};">${title}</div>
          <div style="font-size: 12px; max-width: 150px; margin-top: 5px;">
            ${description.length > 25 ? description.substring(0, 25) + '...' : description}
          </div>
        </div>
          
          <div style="width: 20px; height: 20px; border-radius: 50%; background-color: ${color}; margin: 0; z-index: 2; position: relative; ${isEven ? 'top: -10px' : 'bottom: -10px'}"></div>
          
          <div style="text-align: center; margin-${isEven ? 'top' : 'bottom'}: 5px; font-weight: bold; font-size: 12px;">
            ${event}
          </div>
        </div>
      `;
    });
    
    html += '</div></div>';
    chartDiv.innerHTML = html;
  }
}
  
  // 간단한 레이더 차트 렌더링
  function renderSimpleRadarChart(container, data) {
    const labels = data['601'] || [];
    const dataset1 = data['701'] || [];
    const dataset2 = data['702'] || [];
    const hasSecondDataset = Array.isArray(dataset2) && dataset2.length > 0;
    const seriesLabels = data['603'] || ['시리즈 1', '시리즈 2'];
    
    // 최대값 계산
    const allValues = [...dataset1];
    if (hasSecondDataset) allValues.push(...dataset2);
    const maxValue = Math.max(...allValues.map(v => Number(v) || 0));
    
    const chartDiv = document.createElement('div');
    chartDiv.style.width = '100%';
    chartDiv.style.padding = '20px';
    chartDiv.style.boxSizing = 'border-box';
    container.appendChild(chartDiv);
    
    // SVG 생성
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "400");
    svg.setAttribute("viewBox", "0 0 400 400");
    chartDiv.appendChild(svg);
    
    // 레이더 차트 설정
    const centerX = 200;
    const centerY = 200;
    const radius = 150;
    const numPoints = labels.length;
    const angleStep = (Math.PI * 2) / numPoints;
    
    // 배경 그리드 그리기
    const levels = 5;
    for (let i = 1; i <= levels; i++) {
      const pathData = [];
      const gridRadius = (radius * i) / levels;
      
      for (let j = 0; j < numPoints; j++) {
        const angle = -Math.PI/2 + j * angleStep;
        const x = centerX + gridRadius * Math.cos(angle);
        const y = centerY + gridRadius * Math.sin(angle);
        
        if (j === 0) {
          pathData.push(`M ${x} ${y}`);
        } else {
          pathData.push(`L ${x} ${y}`);
        }
      }
      pathData.push("Z");
      
      const gridPath = document.createElementNS(svgNS, "path");
      gridPath.setAttribute("d", pathData.join(" "));
      gridPath.setAttribute("fill", "none");
      gridPath.setAttribute("stroke", "#ddd");
      gridPath.setAttribute("stroke-width", "1");
      svg.appendChild(gridPath);
    }
    
    // 축 그리기
    for (let i = 0; i < numPoints; i++) {
      const angle = -Math.PI/2 + i * angleStep;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      
      const line = document.createElementNS(svgNS, "line");
      line.setAttribute("x1", centerX);
      line.setAttribute("y1", centerY);
      line.setAttribute("x2", x);
      line.setAttribute("y2", y);
      line.setAttribute("stroke", "#ddd");
      line.setAttribute("stroke-width", "1");
      svg.appendChild(line);
      
      // 레이블 그리기
      const labelX = centerX + (radius + 20) * Math.cos(angle);
      const labelY = centerY + (radius + 20) * Math.sin(angle);
      
      const text = document.createElementNS(svgNS, "text");
      text.setAttribute("x", labelX);
      text.setAttribute("y", labelY);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("dominant-baseline", "middle");
      text.setAttribute("font-size", "12");
      text.textContent = labels[i] || `항목 ${i+1}`;
      svg.appendChild(text);
    }
    
    // 데이터 폴리곤 그리기 (첫 번째 데이터셋)
    drawDataPolygon(dataset1, "#4285F4", 0.5);
    
    // 두 번째 데이터셋이 있으면 그리기
    if (hasSecondDataset) {
      drawDataPolygon(dataset2, "#EA4335", 0.5);
    }
    
    // 범례 추가
    const legendGroup = document.createElementNS(svgNS, "g");
    legendGroup.setAttribute("transform", `translate(${centerX - 100}, ${centerY + radius + 40})`);
    svg.appendChild(legendGroup);
    
    // 첫 번째 데이터셋 범례
    const legend1Rect = document.createElementNS(svgNS, "rect");
    legend1Rect.setAttribute("x", 0);
    legend1Rect.setAttribute("y", 0);
    legend1Rect.setAttribute("width", 15);
    legend1Rect.setAttribute("height", 15);
    legend1Rect.setAttribute("fill", "#4285F4");
    legend1Rect.setAttribute("fill-opacity", "0.5");
    legendGroup.appendChild(legend1Rect);
    
    const legend1Text = document.createElementNS(svgNS, "text");
    legend1Text.setAttribute("x", 25);
    legend1Text.setAttribute("y", 12);
    legend1Text.setAttribute("font-size", "12");
    legend1Text.textContent = seriesLabels[0] || "시리즈 1";
    legendGroup.appendChild(legend1Text);
    
    // 두 번째 데이터셋 범례 (있을 경우)
    if (hasSecondDataset) {
      const legend2Rect = document.createElementNS(svgNS, "rect");
      legend2Rect.setAttribute("x", 100);
      legend2Rect.setAttribute("y", 0);
      legend2Rect.setAttribute("width", 15);
      legend2Rect.setAttribute("height", 15);
      legend2Rect.setAttribute("fill", "#EA4335");
      legend2Rect.setAttribute("fill-opacity", "0.5");
      legendGroup.appendChild(legend2Rect);
      
      const legend2Text = document.createElementNS(svgNS, "text");
      legend2Text.setAttribute("x", 125);
      legend2Text.setAttribute("y", 12);
      legend2Text.setAttribute("font-size", "12");
      legend2Text.textContent = seriesLabels[1] || "시리즈 2";
      legendGroup.appendChild(legend2Text);
    }
    
    // 데이터 폴리곤 그리기 함수
    function drawDataPolygon(dataset, color, opacity) {
      const pathData = [];
      
      for (let i = 0; i < numPoints; i++) {
        const value = i < dataset.length ? Number(dataset[i]) || 0 : 0;
        const ratio = Math.min(value / maxValue, 1); // 1 이상이면 1로 제한
        const angle = -Math.PI/2 + i * angleStep;
        const x = centerX + radius * ratio * Math.cos(angle);
        const y = centerY + radius * ratio * Math.sin(angle);
        
        if (i === 0) {
          pathData.push(`M ${x} ${y}`);
        } else {
          pathData.push(`L ${x} ${y}`);
        }
      }
      pathData.push("Z");
      
      const polygon = document.createElementNS(svgNS, "path");
      polygon.setAttribute("d", pathData.join(" "));
      polygon.setAttribute("fill", color);
      polygon.setAttribute("fill-opacity", opacity);
      polygon.setAttribute("stroke", color);
      polygon.setAttribute("stroke-width", "2");
      svg.appendChild(polygon);
      
      // 데이터 포인트 그리기
      for (let i = 0; i < numPoints; i++) {
        const value = i < dataset.length ? Number(dataset[i]) || 0 : 0;
        const ratio = Math.min(value / maxValue, 1);
        const angle = -Math.PI/2 + i * angleStep;
        const x = centerX + radius * ratio * Math.cos(angle);
        const y = centerY + radius * ratio * Math.sin(angle);
        
        const dot = document.createElementNS(svgNS, "circle");
        dot.setAttribute("cx", x);
        dot.setAttribute("cy", y);
        dot.setAttribute("r", "4");
        dot.setAttribute("fill", color);
        svg.appendChild(dot);
        
        // 값 표시
        const valueText = document.createElementNS(svgNS, "text");
        valueText.setAttribute("x", x);
        valueText.setAttribute("y", y - 10);
        valueText.setAttribute("text-anchor", "middle");
        valueText.setAttribute("font-size", "10");
        valueText.textContent = value;
        svg.appendChild(valueText);
      }
    }
  }
  
  // 인포그래픽 생성 버튼에 이벤트 리스너 연결
  document.getElementById('generate-button').addEventListener('click', function() {
    console.log('인포그래픽 생성 버튼 클릭됨');
    
    try {
      // CSV 데이터 가져오기
      const csvInput = document.getElementById('csv-input');
      const csvText = csvInput.value;
      console.log('CSV 데이터 길이:', csvText.length);
      
      // CSV 파싱
      const parseResult = parseCSVData(csvText);
      const data = parseResult.data;
      
      // 미리보기 컨테이너 가져오기
      const previewContainer = document.getElementById('preview-container');
      console.log('미리보기 컨테이너 찾음:', !!previewContainer);
      
      // 인포그래픽 렌더링
      renderSimpleChart(previewContainer, data);
      
      // 다운로드 버튼 활성화
      const downloadButton = document.getElementById('download-button');
      if (downloadButton) {
        downloadButton.disabled = false;
      }
    } catch (error) {
      console.error('인포그래픽 생성 중 오류:', error);
      
      // 오류 메시지 표시
      const errorContainer = document.getElementById('error-container');
      if (errorContainer) {
        errorContainer.innerHTML = `<div class="alert alert-danger">인포그래픽 생성 중 오류가 발생했습니다: ${error.message}</div>`;
      }
    }
  });
});
</script>
  
</body>
</html>
