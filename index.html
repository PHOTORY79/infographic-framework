<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>인포그래픽 포토리 프레임워크</title>
  <link rel="stylesheet" href="styles.css">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Font Awesome 아이콘 사용을 위한 CDN -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
  <div class="container">
    <header class="header">
      <h1>인포그래픽 프레임워크</h1>
      <p>CSV 데이터를 구조화된 인포그래픽으로 변환하는 도구</p>
    </header>

  <!-- 1) CSV 입력 -->
<section id="input-section" class="my-4">
  <h2>CSV 데이터 입력</h2>
  <textarea id="csv-input" class="form-control" rows="6"
    placeholder="여기에 AI가 생성한 완성된 CSV를 붙여넣으세요"></textarea>
  <div class="mt-2">
    <button id="generate-button" class="btn btn-primary">
      <i class="fas fa-magic"></i> 인포그래픽 생성
    </button>
    <button id="clear-button" class="btn btn-secondary">
      <i class="fas fa-eraser"></i> 초기화
    </button>

  </div>
</section>

<!-- 2) 미리보기 -->
<section id="preview-section" class="my-4">
  <h2>미리보기</h2>
  <div id="preview-container" class="border p-3" style="min-height:200px;">
    <!-- 인포그래픽 SVG가 렌더링됩니다 -->
  </div>
</section>

<!-- 3) 내보내기 -->
<section id="export-section" class="my-4">
  <h2>내보내기</h2>
  <button id="download-button" class="btn btn-success" disabled>
    <i class="fas fa-download"></i> SVG 다운로드
  </button>
  <button id="copy-svg-button" class="btn btn-secondary" disabled>
    <i class="fas fa-copy"></i> SVG 복사
  </button>
  <button id="copy-json-button" class="btn btn-secondary" disabled>
    <i class="fas fa-code"></i> JSON 복사
  </button>
</section>


  <!-- 도움말 버튼 -->
  <button class="help-btn" id="helpBtn" title="도움말">
    <i class="fas fa-question"></i>
  </button>

  <!-- XLSX.js 라이브러리 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- 모듈화된 JavaScript 파일들 -->
 

  <script>
  // 페이지 완전히 로드된 후 실행
  window.addEventListener('load', function() {
    // 요소 참조
    const templateSelector = document.getElementById('template-selector');
    const csvInput = document.getElementById('csv-input');
    const chartTypeSelector = document.getElementById('chart-type-selector');
    const errorContainer = document.getElementById('error-container');
    
    // 템플릿 데이터 (templates 전역 변수가 없는 경우 대비)
    const templateData = {
      'bar-chart': `101,Bar Chart\n102,Business Presentation\n103,Executives\n201,Numerical\n202,Comparison\n301,Vertical\n302,Corporate\n401,분기별 매출 실적\n402,매 분기 꾸준한 성장세를 보이고 있습니다.\n403,Values Only\n501,SVG\n601,["Q1", "Q2", "Q3", "Q4"]\n602,"매출(백만원)"\n701,[120, 150, 130, 180]\n706,160`,
      'pie-chart': `101,Pie Chart\n102,Report\n103,Stakeholders\n201,Categorical\n202,Composition\n301,Single Focus\n302,Vibrant\n401,지역별 매출 비중\n403,Percentage\n501,SVG\n601,["서울", "부산", "인천", "대구", "광주"]\n701,[40, 25, 15, 12, 8]`,
      'line-chart': `101,Line Chart\n102,Business Presentation\n201,Temporal\n202,Trend\n301,Horizontal\n302,Corporate\n401,분기별 매출 추이\n501,SVG\n601,["Q1", "Q2", "Q3", "Q4"]\n602,"매출(백만원)"\n701,[120, 150, 130, 180]`,
      'radar-chart': `101,Radar Chart\n102,Comparison Analysis\n202,Comparison\n301,Single Focus\n302,Brand Colors\n401,제품 성능 비교\n501,SVG\n601,["성능", "가격", "디자인", "내구성", "사용성"]\n602,"점수"\n603,["제품 A", "제품 B"]\n606,["0", "1", "2", "3", "4", "5"]\n701,[4, 3, 5, 4, 3]\n702,[3, 5, 2, 5, 4]`,
      'process-diagram': `101,Process Diagram\n102,Educational\n202,Sequential\n301,Horizontal\n302,Vibrant\n304,Flat Icons\n305,Arrows\n306,Size Variation\n401,5단계 제품 개발 프로세스\n402,아이디어부터 출시까지의 주요 단계\n501,SVG\n504,Sequential Reveal\n601,["아이디어 발굴", "컨셉 개발", "설계", "테스트", "출시"]\n701,["새로운 시장 기회 탐색\\n경쟁사 분석\\n고객 니즈 파악", "제품 컨셉 정의\\n기능 명세\\n시장성 평가", "상세 설계\\n프로토타입 개발\\n생산 계획", "품질 테스트\\n사용자 테스트\\n피드백 수집", "마케팅 캠페인\\n판매 채널 확보\\n고객 지원 준비"]`,
      'comparison-chart': `101,Comparison Chart\n102,Marketing\n201,Numerical\n202,Comparison\n301,Split Screen\n302,Brand Colors\n401,제품 기능 비교\n501,SVG\n601,["크기", "속도", "성능", "가격", "디자인"]\n603,["제품 A", "제품 B"]\n701,[8, 6, 9, 5, 8]\n702,[5, 9, 7, 7, 6]`,
      'timeline': `101,Timeline\n102,Educational\n201,Temporal\n202,Sequential\n301,Horizontal\n302,Cool Tones\n401,프로젝트 타임라인\n501,SVG\n601,["1월", "2월", "3월", "4월", "5월"]\n602,"진행도"\n701,["프로젝트 시작", "요구사항 분석", "디자인 완료", "개발 단계", "출시"]\n702,["초기 계획 및 팀 구성", "사용자 요구사항 수집 및 분석", "UI/UX 디자인 완료", "코어 기능 개발", "제품 출시 및 마케팅"]`
    };
    
    // 템플릿 선택 이벤트 직접 연결
    if (templateSelector && csvInput) {
      templateSelector.addEventListener('change', function() {
        const selectedTemplate = this.value;
        const templateContent = templateData[selectedTemplate];
        
        if (templateContent) {
          // CSV 입력 필드에 템플릿 데이터 적용
          csvInput.value = templateContent;
          
          // 차트 유형 추출 및 변경
          const chartTypeMatch = templateContent.match(/101,(.*)/);
          if (chartTypeMatch && chartTypeSelector) {
            chartTypeSelector.value = chartTypeMatch[1].trim();
          }
          
          // 성공 메시지 표시
          if (errorContainer) {
            errorContainer.innerHTML = '<div class="alert alert-success">템플릿이 적용되었습니다.</div>';
            setTimeout(() => { errorContainer.innerHTML = ''; }, 3000);
          }
        }
      });
    }
  });
</script>

<!-- 디버깅 스크립트 추가 -->

<script>
    // ─── 공통 색상 팔레트 함수 (새로 추가) ───
function getColorScheme(key) {
  const palettes = {
    corporate:      ['#4285F4', '#34A853', '#FBBC05', '#EA4335', '#5F6368'],
    monochromatic:  ['#333333', '#555555', '#777777', '#999999', '#BBBBBB'],
    analogous:      ['#FFB366', '#FFE066', '#66FFB3', '#66B3FF', '#B366FF'],
    complementary:  ['#4285F4', '#FBBC05', '#34A853', '#EA4335', '#5F6368'],
    triadic:        ['#4285F4', '#FB4226', '#42FB97', '#FB42EC', '#FBF142'],
    pastel:         ['#FFB6C1', '#AFEEEE', '#FFDAB9', '#D8BFD8', '#FFFACD'],
    vibrant:        ['#FF5733', '#33FF57', '#3357FF', '#FF33F5', '#F5FF33'],
    grayscale:      ['#FFFFFF', '#CCCCCC', '#999999', '#666666', '#333333'],
    cooltones:      ['#3498DB', '#1ABC9C', '#2ECC71', '#9B59B6', '#34495E'],
    warmtones:      ['#E74C3C', '#F39C12', '#D35400', '#F1C40F', '#E67E22'],
    natureinspired: ['#228B22', '#2E8B57', '#6B8E23', '#556B2F', '#8FBC8F'],
    datadriven:     ['#1F77B4', '#FF7F0E', '#2CA02C', '#D62728', '#9467BD'],
    brandcolors:    ['#1877F2', '#E4405F', '#1DA1F2', '#0A66C2', '#FF0000'],
    highcontrast:   ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF'],
    accessible:     ['#005A9C', '#107C10', '#FFB900', '#A80000', '#5C5C5C'],
    기업스타일:     ['#4285F4', '#34A853', '#FBBC05', '#EA4335', '#5F6368'],
    단색:           ['#333333', '#555555', '#777777', '#999999', '#BBBBBB'],
    유사색:         ['#FFB366', '#FFE066', '#66FFB3', '#66B3FF', '#B366FF'],
    보색:           ['#4285F4', '#FBBC05', '#34A853', '#EA4335', '#5F6368'],
    삼색:           ['#4285F4', '#FB4226', '#42FB97', '#FB42EC', '#FBF142'],
    파스텔:         ['#FFB6C1', '#AFEEEE', '#FFDAB9', '#D8BFD8', '#FFFACD'],
    선명한:         ['#FF5733', '#33FF57', '#3357FF', '#FF33F5', '#F5FF33'],
    회색조:         ['#FFFFFF', '#CCCCCC', '#999999', '#666666', '#333333'],
    차가운톤:      ['#3498DB', '#1ABC9C', '#2ECC71', '#9B59B6', '#34495E'],
    따듯한톤:      ['#E74C3C', '#F39C12', '#D35400', '#F1C40F', '#E67E22'],
    자연영감:      ['#228B22', '#2E8B57', '#6B8E23', '#556B2F', '#8FBC8F'],
    데이터기반:    ['#1F77B4', '#FF7F0E', '#2CA02C', '#D62728', '#9467BD'],
    브랜드색상:    ['#1877F2', '#E4405F', '#1DA1F2', '#0A66C2', '#FF0000'],
    고대비:         ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF'],
    접근성고려:    ['#005A9C', '#107C10', '#FFB900', '#A80000', '#5C5C5C'],
    // 필요하면 계속 추가
  };
  key = (key || 'corporate').toLowerCase().replace(/\s+/g, '');
  return palettes[key] || palettes['corporate'];
}
// ─── 팔레트에서 n번째 색을 돌려주는 헬퍼 ───
function getPaletteColor(index, schemeKey = 'corporate') {
  const palette = getColorScheme(schemeKey);
  return palette[index % palette.length];
}

  // ─── 레이아웃 옵션 헬퍼 ───
function getLayoutOption(layoutValue) {
  const v = (layoutValue || '').toLowerCase();
  if (v.includes('vertical'))   return 'vertical';
  if (v.includes('horizontal')) return 'horizontal';
  return 'default';
}

window.addEventListener('load', function() {
  console.log('페이지 로드 완료');
  
  // CSV 파싱 함수 직접 구현
 function parseCSVData(csvText) {
  const result = { data: {} };
  const rawLines = csvText.split(/\r?\n/);
  let buffer = '';
  let currentId = null;

  rawLines.forEach((rawLine, index) => {
    // 새 속성 시작? (ID,값 분리)
    if (currentId === null) {
      const commaIdx = rawLine.indexOf(',');
      if (commaIdx === -1) return;
      currentId = rawLine.slice(0, commaIdx).trim();
      buffer = rawLine.slice(commaIdx + 1).trim();
    } else {
      // 멀티라인 JSON 배열 계속 누적
      buffer += rawLine.trim();
    }

    // 배열 끝인지 체크 (']'로 끝나야)
    if (buffer.startsWith('[') && !buffer.endsWith(']')) {
      return; // 아직 끝 아님
    }

    // 값 파싱
    let value;
    if (buffer.startsWith('[')) {
      try {
        value = JSON.parse(buffer);
      } catch {
        value = buffer;
      }
    } else if (buffer.startsWith('"') && buffer.endsWith('"')) {
      value = buffer.slice(1, -1);
    } else {
      value = buffer;
    }

    result.data[currentId] = value;
    currentId = null;
    buffer = '';
  });

  console.log('파싱된 CSV 데이터:', result.data);
  return result;
}

  // 간단한 인포그래픽 렌더링 함수
  function renderSimpleChart(container, data) {
    // 컨테이너 초기화
    container.innerHTML = '';
    
    const visualizationType = data['101'] ? data['101'].toLowerCase() : '';
    const chartTitle = data['401'] || '인포그래픽';
    
    // 간단한 헤더 추가
    const header = document.createElement('h3');
    header.textContent = chartTitle;
    header.style.textAlign = 'center';
    container.appendChild(header);
    
    if (visualizationType.includes('bar chart')) {
      renderSimpleBarChart(container, data);
    } else if (visualizationType.includes('pie chart')) {
      renderSimplePieChart(container, data);
    } else if (visualizationType.includes('line chart')) {
      renderSimpleLineChart(container, data);
    } else if (visualizationType.includes('process diagram')) {
      renderSimpleProcessDiagram(container, data);
    } else if (visualizationType.includes('timeline')) {
      renderSimpleTimeline(container, data);
    } else if (visualizationType.includes('radar chart')) {
      renderSimpleRadarChart(container, data);
    } else if (visualizationType.includes('comparison chart')) {
      renderSimpleComparisonChart(container, data);
    } else {
      container.innerHTML += `
        <div style="text-align:center; color:#e74c3c; padding:30px;">
          <i class="fas fa-exclamation-triangle" style="font-size: 3rem;"></i>
          <p style="margin-top:20px;">차트 유형 "${data['101'] || '지정되지 않음'}"에 대한 렌더링 함수가 준비 중입니다.</p>
        </div>
      `;
    }
  }

// 막대 차트를 SVG로 렌더링 (방향 지원 추가)
function renderSimpleBarChart(container, data) {
  const xLabels = data['601'] || [];
  const dataset = data['701'] || [];
  const chartTitle = data['401'] || '막대 차트';
// const isHorizontal = data['301'] && data['301'].toLowerCase().includes('horizontal');
  const layout = getLayoutOption(data['301']);
  const isHorizontal = (layout === 'horizontal');
  const scheme = getColorScheme(data['302']);
  
  console.log('바차트 방향:', isHorizontal ? '수평' : '수직');
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 생성
  const svgWidth = 800;
  const svgHeight = 500;
  const paddingX = 60;
  const paddingY = 80;
  const chartWidth = svgWidth - 2 * paddingX;
  const chartHeight = svgHeight - 2 * paddingY;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 최대값 계산
  const maxValue = Math.max(...dataset.map(v => Number(v) || 0));
  const values = dataset.map(v => Number(v) || 0);
  
  if (isHorizontal) {
    // 수평 막대 차트 (바가 왼쪽에서 오른쪽으로)
    
    // Y축 추가 (세로축 - 카테고리)
    const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxis.setAttribute('x1', paddingX);
    yAxis.setAttribute('y1', paddingY);
    yAxis.setAttribute('x2', paddingX);
    yAxis.setAttribute('y2', svgHeight - paddingY);
    yAxis.setAttribute('stroke', '#333');
    yAxis.setAttribute('stroke-width', '2');
    svg.appendChild(yAxis);
    
    // X축 추가 (가로축 - 값)
    const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxis.setAttribute('x1', paddingX);
    xAxis.setAttribute('y1', svgHeight - paddingY);
    xAxis.setAttribute('x2', svgWidth - paddingX);
    xAxis.setAttribute('y2', svgHeight - paddingY);
    xAxis.setAttribute('stroke', '#333');
    xAxis.setAttribute('stroke-width', '2');
    svg.appendChild(xAxis);
    
    // 막대 높이 계산
    const barHeight = chartHeight / xLabels.length / 2;
    const barSpacing = chartHeight / xLabels.length;
    
    // 막대 생성
    for (let i = 0; i < Math.min(xLabels.length, values.length); i++) {
      const value = values[i];
      const width = (value / maxValue) * chartWidth;
      const y = paddingY + i * barSpacing + barHeight / 2;
      const x = paddingX;
      
      // 막대 추가
      const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bar.setAttribute('x', x);
      bar.setAttribute('y', y);
      bar.setAttribute('width', width);
      bar.setAttribute('height', barHeight);
      bar.setAttribute('fill', scheme[i % scheme.length]);
      svg.appendChild(bar);
      
      // 값 라벨 추가
      const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valueText.setAttribute('x', x + width + 10);
      valueText.setAttribute('y', y + barHeight / 2);
      valueText.setAttribute('dominant-baseline', 'middle');
      valueText.setAttribute('font-size', '12');
      valueText.textContent = value;
      svg.appendChild(valueText);
      
      // Y축 라벨 추가 (카테고리)
      const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      labelText.setAttribute('x', paddingX - 10);
      labelText.setAttribute('y', y + barHeight / 2);
      labelText.setAttribute('text-anchor', 'end');
      labelText.setAttribute('dominant-baseline', 'middle');
      labelText.setAttribute('font-size', '12');
      labelText.textContent = xLabels[i];
      svg.appendChild(labelText);
    }
  } else {
    // 수직 막대 차트 (기존 코드)
    
    // X축 추가
    const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    xAxis.setAttribute('x1', paddingX);
    xAxis.setAttribute('y1', svgHeight - paddingY);
    xAxis.setAttribute('x2', svgWidth - paddingX);
    xAxis.setAttribute('y2', svgHeight - paddingY);
    xAxis.setAttribute('stroke', '#333');
    xAxis.setAttribute('stroke-width', '2');
    svg.appendChild(xAxis);
    
    // Y축 추가
    const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    yAxis.setAttribute('x1', paddingX);
    yAxis.setAttribute('y1', paddingY);
    yAxis.setAttribute('x2', paddingX);
    yAxis.setAttribute('y2', svgHeight - paddingY);
    yAxis.setAttribute('stroke', '#333');
    yAxis.setAttribute('stroke-width', '2');
    svg.appendChild(yAxis);
    
    // 막대 너비 계산
    const barWidth = chartWidth / xLabels.length / 2;
    const barSpacing = chartWidth / xLabels.length;
    
    // 막대 생성
    for (let i = 0; i < Math.min(xLabels.length, values.length); i++) {
      const value = values[i];
      const height = (value / maxValue) * chartHeight;
      const x = paddingX + i * barSpacing + barWidth / 2;
      const y = svgHeight - paddingY - height;
      
      // 막대 추가
      const bar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      bar.setAttribute('x', x);
      bar.setAttribute('y', y);
      bar.setAttribute('width', barWidth);
      bar.setAttribute('height', height);
      bar.setAttribute('fill', scheme[i % scheme.length]);
      svg.appendChild(bar);
      
      // 값 라벨 추가
      const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valueText.setAttribute('x', x + barWidth / 2);
      valueText.setAttribute('y', y - 10);
      valueText.setAttribute('text-anchor', 'middle');
      valueText.setAttribute('font-size', '12');
      valueText.textContent = value;
      svg.appendChild(valueText);
      
      // X축 라벨 추가
      const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      labelText.setAttribute('x', x + barWidth / 2);
      labelText.setAttribute('y', svgHeight - paddingY + 20);
      labelText.setAttribute('text-anchor', 'middle');
      labelText.setAttribute('font-size', '12');
      labelText.textContent = xLabels[i];
      svg.appendChild(labelText);
    }
  }
}
  
// 파이 차트를 SVG로 렌더링 (수정 버전)
function renderSimplePieChart(container, data) {
  const labels = data['601'] || [];
  const values = data['701'] || [];
  const chartTitle = data['401'] || '파이 차트';
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정
  const svgWidth = 800;
  const svgHeight = 500;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 고정 색상 배열 (HSL 대신 사용)
 // const colors = [
 //  '#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8334A2',
 // '#1A73E8', '#D93025', '#F9AB00', '#1E8E3E', '#7627BB'
 // ]; 
  const colors = getColorScheme(data['302']);

  // 데이터 합계 및 각도 계산
  const total = values.reduce((sum, val) => sum + (Number(val) || 0), 0);
  
  // 차트 중심점 및 반지름
  const centerX = 250;
  const centerY = 250;
  const radius = 150;
  
  // 파이 조각 생성
  let startAngle = 0;
  
  for (let i = 0; i < values.length; i++) {
    const value = Number(values[i]) || 0;
    const percentage = value / total;
    const endAngle = startAngle + percentage * 2 * Math.PI;
    
    // 파이 조각 경로 계산
    const x1 = centerX + Math.cos(startAngle) * radius;
    const y1 = centerY + Math.sin(startAngle) * radius;
    const x2 = centerX + Math.cos(endAngle) * radius;
    const y2 = centerY + Math.sin(endAngle) * radius;
    
    const largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;
    
    const pathData = `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
    
    // 고정 색상 배열에서 색상 선택
    const color = colors[i % colors.length];
    
    // 파이 조각 생성 (인라인 스타일 추가)
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathData);
    path.setAttribute('fill', color);
    path.setAttribute('stroke', 'white');
    path.setAttribute('stroke-width', '1');
    path.setAttribute('style', `fill: ${color}; fill-opacity: 1;`);
    svg.appendChild(path);
    
    // 텍스트 위치 계산 (조각 중앙)
    const textAngle = startAngle + (endAngle - startAngle) / 2;
    const textRadius = radius * 0.7;
    const textX = centerX + Math.cos(textAngle) * textRadius;
    const textY = centerY + Math.sin(textAngle) * textRadius;
    
    // 퍼센트 텍스트 추가 (조각 안)
    if (percentage > 0.05) { // 5% 이상인 경우만 표시
      const percentText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      percentText.setAttribute('x', textX);
      percentText.setAttribute('y', textY);
      percentText.setAttribute('text-anchor', 'middle');
      percentText.setAttribute('dominant-baseline', 'middle');
      percentText.setAttribute('fill', 'white');
      percentText.setAttribute('font-size', '14');
      percentText.setAttribute('font-weight', 'bold');
      percentText.textContent = `${Math.round(percentage * 100)}%`;
      svg.appendChild(percentText);
    }
    
    // 범례 항목
    const legendY = 120 + i * 30;
    
    // 범례 색상 표시 (인라인 스타일 추가)
    const legendColor = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    legendColor.setAttribute('x', 500);
    legendColor.setAttribute('y', legendY);
    legendColor.setAttribute('width', '20');
    legendColor.setAttribute('height', '20');
    legendColor.setAttribute('fill', color);
    legendColor.setAttribute('style', `fill: ${color}; fill-opacity: 1;`);
    svg.appendChild(legendColor);
    
    // 범례 레이블
    const legendText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    legendText.setAttribute('x', 530);
    legendText.setAttribute('y', legendY + 15);
    legendText.setAttribute('font-size', '14');
    legendText.textContent = `${labels[i] || `항목 ${i+1}`}: ${value} (${Math.round(percentage * 100)}%)`;
    svg.appendChild(legendText);
    
    startAngle = endAngle;
  }
}

  //라인차트 렌더링
function renderSimpleLineChart(container, data) {
  const xLabels = data['601'] || [];
  const dataset = data['701'] || [];
  const dataset2 = data['702'] || [];
  const hasSecondDataset = Array.isArray(dataset2) && dataset2.length > 0;
  const seriesLabels = data['603'] || ['시리즈 1', '시리즈 2'];
  const chartTitle = data['401'] || '라인 차트';
  // 레이아웃 방향 결정 (추가)
  const layout = getLayoutOption(data['301']); // 'vertical', 'horizontal', or 'default'
  const isHorizontal = (layout === 'horizontal');
  console.log('Line chart layout:', isHorizontal ? 'Horizontal' : 'Vertical'); // 디버깅 로그
  
  // 데이터의 302(색상 스키마) 값을 받아 팔레트 얻기
  const colors = getColorScheme(data['302']);
  const primaryColor   = colors[0] || '#4285F4';   // 첫 번째 시리즈용
  const secondaryColor = colors[1] || '#EA4335';   // 두 번째 시리즈용

  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 생성
  const svgWidth = 800;
  const svgHeight = 400;
  const paddingX = 50;
  const paddingY = 50;
  const chartWidth = svgWidth - 2 * paddingX;
  const chartHeight = svgHeight - 2 * paddingY;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 데이터 값 범위 계산
  const allValues = [...dataset];
  if (hasSecondDataset) allValues.push(...dataset2);
  let minValue = Math.min(...allValues.map(v => Number(v) || 0));
  minValue = Math.floor(minValue * 0.9); // 약간의 여유 공간
  
  let maxValue = Math.max(...allValues.map(v => Number(v) || 0));
  maxValue = Math.ceil(maxValue * 1.1); // 약간의 여유 공간
  
  // 그리드 라인 및 Y축 레이블
  if (!isHorizontal) { // <-- if 시작
    const gridLines = 5;
    for (let i = 0; i <= gridLines; i++) {
    const y = paddingY + chartHeight - (i / gridLines) * chartHeight;
    const value = minValue + (i / gridLines) * (maxValue - minValue);
    
    // 그리드 라인
    const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    gridLine.setAttribute('x1', paddingX);
    gridLine.setAttribute('y1', y);
    gridLine.setAttribute('x2', paddingX + chartWidth);
    gridLine.setAttribute('y2', y);
    gridLine.setAttribute('stroke', '#e0e0e0');
    gridLine.setAttribute('stroke-width', '1');
    svg.appendChild(gridLine);
    
    // Y축 레이블
    const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yLabel.setAttribute('x', paddingX - 10);
    yLabel.setAttribute('y', y);
    yLabel.setAttribute('text-anchor', 'end');
    yLabel.setAttribute('alignment-baseline', 'middle');
    yLabel.setAttribute('font-size', '12');
    yLabel.textContent = Math.round(value);
    svg.appendChild(yLabel);
   }
  
  // X축 라인
  const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  xAxis.setAttribute('x1', paddingX);
  xAxis.setAttribute('y1', paddingY + chartHeight);
  xAxis.setAttribute('x2', paddingX + chartWidth);
  xAxis.setAttribute('y2', paddingY + chartHeight);
  xAxis.setAttribute('stroke', '#333');
  xAxis.setAttribute('stroke-width', '1');
  svg.appendChild(xAxis);
  
  // X축 레이블
  const xStep = chartWidth / (xLabels.length - 1 || 1);
  xLabels.forEach((label, i) => {
    const x = paddingX + i * xStep;
    const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    xLabel.setAttribute('x', x);
    xLabel.setAttribute('y', paddingY + chartHeight + 20);
    xLabel.setAttribute('text-anchor', 'middle');
    xLabel.setAttribute('font-size', '12');
    xLabel.textContent = label;
    svg.appendChild(xLabel);
  });

  // 첫 번째 데이터셋 라인
  const linePath1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  let path1Data = '';
  
  dataset.forEach((value, i) => {
    if (i >= xLabels.length) return;
    
    const x = paddingX + i * xStep;
    const yValue = Number(value) || 0;
    const normalizedValue = (yValue - minValue) / (maxValue - minValue);
    const y = paddingY + chartHeight - (normalizedValue * chartHeight);
    
    path1Data += `${i === 0 ? 'M' : 'L'} ${x} ${y} `;
  });
  
  linePath1.setAttribute('d', path1Data);
  linePath1.setAttribute('fill', 'none');
  linePath1.setAttribute('stroke', primaryColor);
  linePath1.setAttribute('stroke-width', '2');
  linePath1.setAttribute('style', `stroke: ${primaryColor}; stroke-opacity: 1;`);
  svg.appendChild(linePath1);
  
  // 첫 번째 데이터셋 포인트
  dataset.forEach((value, i) => {
    if (i >= xLabels.length) return;
    
    const x = paddingX + i * xStep;
    const yValue = Number(value) || 0;
    const normalizedValue = (yValue - minValue) / (maxValue - minValue);
    const y = paddingY + chartHeight - (normalizedValue * chartHeight);
    
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', '4');
    circle.setAttribute('fill', primaryColor);
    circle.setAttribute('style', `fill: ${primaryColor}; fill-opacity: 1;`);
    svg.appendChild(circle);
    
    const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    valueText.setAttribute('x', x);
    valueText.setAttribute('y', y - 10);
    valueText.setAttribute('text-anchor', 'middle');
    valueText.setAttribute('font-size', '10');
    valueText.textContent = value;
    svg.appendChild(valueText);
  });
  
  // 두 번째 데이터셋 (있을 경우)
  if (hasSecondDataset) {
    const linePath2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let path2Data = '';
    
    dataset2.forEach((value, i) => {
      if (i >= xLabels.length) return;
      
      const x = paddingX + i * xStep;
      const yValue = Number(value) || 0;
      const normalizedValue = (yValue - minValue) / (maxValue - minValue);
      const y = paddingY + chartHeight - (normalizedValue * chartHeight);
      
      path2Data += `${i === 0 ? 'M' : 'L'} ${x} ${y} `;
    });
    
    linePath2.setAttribute('d', path2Data);
    linePath2.setAttribute('fill', 'none');
    linePath2.setAttribute('stroke', secondaryColor);
    linePath2.setAttribute('stroke-width', '2');
    linePath2.setAttribute('style', `stroke: ${secondaryColor}; stroke-opacity: 1;`);
    svg.appendChild(linePath2);
    
    // 두 번째 데이터셋 포인트
    dataset2.forEach((value, i) => {
      if (i >= xLabels.length) return;
      
      const x = paddingX + i * xStep;
      const yValue = Number(value) || 0;
      const normalizedValue = (yValue - minValue) / (maxValue - minValue);
      const y = paddingY + chartHeight - (normalizedValue * chartHeight);
      
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', x);
      circle.setAttribute('cy', y);
      circle.setAttribute('r', '4');
      circle.setAttribute('fill', secondaryColor);
      circle.setAttribute('style', `fill: ${secondaryColor}; fill-opacity: 1;`);
      svg.appendChild(circle);
      
      const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valueText.setAttribute('x', x);
      valueText.setAttribute('y', y - 10);
      valueText.setAttribute('text-anchor', 'middle');
      valueText.setAttribute('font-size', '10');
      valueText.textContent = value;
      svg.appendChild(valueText);
    });
  }
  
  // 범례
  const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  legendGroup.setAttribute('transform', `translate(${svgWidth - 200}, 40)`);
  
  // 첫 번째 시리즈 범례
  const legendLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  legendLine1.setAttribute('x1', 0);
  legendLine1.setAttribute('y1', 0);
  legendLine1.setAttribute('x2', 30);
  legendLine1.setAttribute('y2', 0);
  legendLine1.setAttribute('stroke', primaryColor);
  legendLine1.setAttribute('stroke-width', '2');
  legendGroup.appendChild(legendLine1);
  
  const legendCircle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  legendCircle1.setAttribute('cx', 15);
  legendCircle1.setAttribute('cy', 0);
  legendCircle1.setAttribute('r', '3');
  legendCircle1.setAttribute('fill', primaryColor);
  legendGroup.appendChild(legendCircle1);
  
  const legendText1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  legendText1.setAttribute('x', 40);
  legendText1.setAttribute('y', 5);
  legendText1.setAttribute('font-size', '12');
  legendText1.textContent = seriesLabels[0];
  legendGroup.appendChild(legendText1);
  
  if (hasSecondDataset) {
    // 두 번째 시리즈 범례
    const legendLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    legendLine2.setAttribute('x1', 100);
    legendLine2.setAttribute('y1', 0);
    legendLine2.setAttribute('x2', 130);
    legendLine2.setAttribute('y2', 0);
    legendLine2.setAttribute('stroke', secondaryColor);
    legendLine2.setAttribute('stroke-width', '2');
    legendGroup.appendChild(legendLine2);
    
    const legendCircle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    legendCircle2.setAttribute('cx', 115);
    legendCircle2.setAttribute('cy', 0);
    legendCircle2.setAttribute('r', '3');
    legendCircle2.setAttribute('fill', secondaryColor);
    legendGroup.appendChild(legendCircle2);
    
    const legendText2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    legendText2.setAttribute('x', 140);
    legendText2.setAttribute('y', 5);
    legendText2.setAttribute('font-size', '12');
    legendText2.textContent = seriesLabels[1];
    legendGroup.appendChild(legendText2);
  }
  svg.appendChild(legendGroup);
} // <-- if 끝
else { // 수평 차트 (Horizontal) 로직 시작

  // 세로축 (항목/카테고리 축) - 수평 차트에서는 왼쪽에 위치
  const yAxis_h = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  yAxis_h.setAttribute('x1', paddingX); // 왼쪽 패딩 위치 (X 좌표 시작)
  yAxis_h.setAttribute('y1', paddingY); // 위쪽 패딩 위치 (Y 좌표 시작)
  yAxis_h.setAttribute('x2', paddingX); // 왼쪽 패딩 위치 (X 좌표 끝 - 수직선이므로 동일)
  yAxis_h.setAttribute('y2', paddingY + chartHeight); // 위쪽 패딩 + 차트 높이 (Y 좌표 끝)
  yAxis_h.setAttribute('stroke', '#333'); // 선 색상
  yAxis_h.setAttribute('stroke-width', '1'); // 선 두께
  svg.appendChild(yAxis_h); // 생성한 선을 SVG에 추가

  // 가로축 (값 축) - 수평 차트에서는 아래쪽에 위치
  const xAxis_h = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  xAxis_h.setAttribute('x1', paddingX); // 왼쪽 패딩 위치 (X 좌표 시작)
  xAxis_h.setAttribute('y1', paddingY + chartHeight); // 위쪽 패딩 + 차트 높이 (Y 좌표 시작 - 차트 바닥)
  xAxis_h.setAttribute('x2', paddingX + chartWidth); // 왼쪽 패딩 + 차트 너비 (X 좌표 끝)
  xAxis_h.setAttribute('y2', paddingY + chartHeight); // 위쪽 패딩 + 차트 높이 (Y 좌표 끝 - 수평선이므로 동일)
  xAxis_h.setAttribute('stroke', '#333'); // 선 색상
  xAxis_h.setAttribute('stroke-width', '1'); // 선 두께
  svg.appendChild(xAxis_h); // 생성한 선을 SVG에 추가
  
  const gridLines = 5; // 수직 차트와 동일하게 5개의 그리드/눈금 구간을 사용합니다.
for (let i = 0; i <= gridLines; i++) {
    // 현재 눈금/그리드 라인이 위치할 X 좌표를 계산합니다. (값 축 기준)
    const x = paddingX + (i / gridLines) * chartWidth;
    // 현재 눈금에 해당하는 실제 데이터 값을 계산합니다. (최소값 ~ 최대값 범위 내)
    const value = minValue + (i / gridLines) * (maxValue - minValue);

    // 세로 그리드 라인 생성 (값 축 눈금에 맞춰 세로로 그림)
    const gridLine_h = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    gridLine_h.setAttribute('x1', x);
    gridLine_h.setAttribute('y1', paddingY); // 차트 영역 상단에서 시작
    gridLine_h.setAttribute('x2', x);
    gridLine_h.setAttribute('y2', paddingY + chartHeight); // 차트 영역 하단까지
    gridLine_h.setAttribute('stroke', '#e0e0e0'); // 그리드 라인 색상 (연한 회색)
    gridLine_h.setAttribute('stroke-width', '1'); // 그리드 라인 두께
    svg.appendChild(gridLine_h);

    // 가로축 (값 축) 레이블 생성 (X축 아래에 숫자 표시)
    const xLabel_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    xLabel_h.setAttribute('x', x); // 해당 눈금의 X 좌표
    xLabel_h.setAttribute('y', paddingY + chartHeight + 20); // 가로축 선보다 20px 아래
    xLabel_h.setAttribute('text-anchor', 'middle'); // 텍스트를 X 좌표 기준으로 중앙 정렬
    xLabel_h.setAttribute('font-size', '12'); // 글자 크기
    xLabel_h.textContent = Math.round(value); // 계산된 값을 반올림하여 텍스트로 표시
    svg.appendChild(xLabel_h);
   }
      // 세로축 (항목/카테고리) 레이블 추가
    const yStep_h = chartHeight / (xLabels.length - 1 || 1); // 각 항목 레이블 간의 세로 간격을 계산합니다.
    xLabels.forEach((label, i) => {
    // 현재 레이블이 위치할 Y 좌표를 계산합니다.
    const y = paddingY + chartHeight - (i * yStep_h);

    // 세로축 레이블 텍스트 요소를 생성합니다.
    const yLabel_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    yLabel_h.setAttribute('x', paddingX - 10); // 세로축 선(yAxis_h)보다 10px 왼쪽에 위치시킵니다.
    yLabel_h.setAttribute('y', y); // 위에서 계산한 Y 좌표에 배치합니다.
    yLabel_h.setAttribute('text-anchor', 'end'); // 텍스트의 끝(오른쪽)을 기준점(x 좌표)에 맞춰 정렬합니다.
    yLabel_h.setAttribute('alignment-baseline', 'middle'); // 텍스트의 세로 중앙을 기준점(y 좌표)에 맞춥니다.
    yLabel_h.setAttribute('font-size', '12'); // 글자 크기를 설정합니다.
    yLabel_h.textContent = label; // xLabels 배열에서 가져온 실제 텍스트 ('Q1', 'Q2' 등)를 표시합니다.
    svg.appendChild(yLabel_h); // 생성한 레이블을 SVG에 추가합니다.
   });
 // --- 수평 차트 데이터 플로팅 시작 ---
 // 첫 번째 데이터셋 라인 그리기 (Horizontal)
    const linePath1_h = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let path1Data_h = '';
    // --- 추가할 코드 (1/2): 선 경로 계산 ---
  dataset.forEach((value, i) => {
    if (i >= xLabels.length) return; // 레이블 개수만큼만 처리
    const y = paddingY + chartHeight - (i * yStep_h); // Y 좌표 (항목 순서 기준)
    const xValue = Number(value) || 0;
    const normalizedValue = (maxValue - minValue === 0) ? 0 : (xValue - minValue) / (maxValue - minValue);
    const x = paddingX + normalizedValue * chartWidth; // X 좌표 (값 기준)
    path1Data_h += (i === 0 ? 'M' : 'L') + ` ${x} ${y} `; // 경로 데이터 생성
  });
  // --- 여기까지 추가 (1/2) ---
  // --- 추가할 코드 (2/2): 선 그리기 ---
    linePath1_h.setAttribute('d', path1Data_h); // 계산된 경로를 'd' 속성에 설정
    linePath1_h.setAttribute('fill', 'none'); // 채우기 없음
    linePath1_h.setAttribute('stroke', primaryColor); // 선 색상
    linePath1_h.setAttribute('stroke-width', '2'); // 선 두께
    linePath1_h.setAttribute('style', `stroke: ${primaryColor}; stroke-opacity: 1;`); // 스타일
    svg.appendChild(linePath1_h); // SVG에 선 추가
    // --- 여기까지 추가 (2/2) ---
  
    // yStep_h 변수는 이미 위의 '세로축 레이블 추가' 부분에서 계산되었으므로 여기서는 재사용합니다.
    // 첫 번째 데이터셋 포인트(점) 및 값 텍스트 추가 (Horizontal)
  dataset.forEach((value, i) => {
    // 항목 레이블 개수(xLabels.length)를 벗어나는 데이터는 그리지 않습니다.
    if (i >= xLabels.length) return;

    // Y 좌표 계산 (선 그리기 로직과 동일)
    const y = paddingY + chartHeight - (i * yStep_h);

    // X 좌표 계산 (선 그리기 로직과 동일)
    const xValue = Number(value) || 0;
    const normalizedValue = (maxValue - minValue === 0) ? 0 : (xValue - minValue) / (maxValue - minValue);
    const x = paddingX + normalizedValue * chartWidth;

    // 데이터 포인트 (점) 생성
    const circle_h = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle_h.setAttribute('cx', x); // 계산된 X 좌표 사용
    circle_h.setAttribute('cy', y); // 계산된 Y 좌표 사용
    circle_h.setAttribute('r', '4'); // 점의 반지름 크기
    circle_h.setAttribute('fill', primaryColor); // 점의 채우기 색상 (첫 번째 시리즈 색상)
    circle_h.setAttribute('style', `fill: ${primaryColor}; fill-opacity: 1;`); // CSS 스타일 설정
    svg.appendChild(circle_h); // 생성한 점을 SVG에 추가

    // 값 텍스트 생성
    const valueText_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    valueText_h.setAttribute('x', x + 10); // 점에서 오른쪽으로 10px 떨어진 위치에 X 좌표 설정
    valueText_h.setAttribute('y', y); // 점과 동일한 Y 좌표 사용
    valueText_h.setAttribute('text-anchor', 'start'); // 텍스트의 시작점(왼쪽)을 X 좌표에 맞춤
    valueText_h.setAttribute('alignment-baseline', 'middle'); // 텍스트의 세로 중앙을 Y 좌표에 맞춤
    valueText_h.setAttribute('font-size', '10'); // 글자 크기
    valueText_h.textContent = value; // 실제 데이터 값(value)을 텍스트 내용으로 설정
    svg.appendChild(valueText_h); // 생성한 값 텍스트를 SVG에 추가
   });

    // 두 번째 데이터셋 처리 (Horizontal) - 데이터가 있을 경우에만 실행됩니다.
  if (hasSecondDataset) {
    // 두 번째 데이터셋 라인 그리기
    const linePath2_h = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    let path2Data_h = '';

    dataset2.forEach((value, i) => {
        if (i >= xLabels.length) return; // 항목 레이블 개수만큼만 그립니다.
        // Y 좌표 계산 (첫 번째 데이터셋과 동일)
        const y = paddingY + chartHeight - (i * yStep_h);
        // X 좌표 계산 (첫 번째 데이터셋과 동일)
        const xValue = Number(value) || 0;
        const normalizedValue = (maxValue - minValue === 0) ? 0 : (xValue - minValue) / (maxValue - minValue);
        const x = paddingX + normalizedValue * chartWidth;
        // 경로 데이터 생성
        path2Data_h += (i === 0 ? 'M' : 'L') + ` ${x} ${y} `;
    });

    linePath2_h.setAttribute('d', path2Data_h);
    linePath2_h.setAttribute('fill', 'none');
    linePath2_h.setAttribute('stroke', secondaryColor); // 두 번째 시리즈 색상 사용
    linePath2_h.setAttribute('stroke-width', '2');
    linePath2_h.setAttribute('style', `stroke: ${secondaryColor}; stroke-opacity: 1;`);
    svg.appendChild(linePath2_h); // 두 번째 선 경로 추가

    // 두 번째 데이터셋 포인트(점) 및 값 텍스트 추가
    dataset2.forEach((value, i) => {
        if (i >= xLabels.length) return;
        // Y 좌표 계산 (첫 번째 데이터셋과 동일)
        const y = paddingY + chartHeight - (i * yStep_h);
         // X 좌표 계산 (첫 번째 데이터셋과 동일)
        const xValue = Number(value) || 0;
        const normalizedValue = (maxValue - minValue === 0) ? 0 : (xValue - minValue) / (maxValue - minValue);
        const x = paddingX + normalizedValue * chartWidth;

        // 데이터 포인트 (점)
        const circle2_h = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle2_h.setAttribute('cx', x);
        circle2_h.setAttribute('cy', y);
        circle2_h.setAttribute('r', '4');
        circle2_h.setAttribute('fill', secondaryColor); // 두 번째 시리즈 색상 사용
        circle2_h.setAttribute('style', `fill: ${secondaryColor}; fill-opacity: 1;`);
        svg.appendChild(circle2_h);

        // 값 텍스트
        const valueText2_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        valueText2_h.setAttribute('x', x + 10);
        valueText2_h.setAttribute('y', y);
        valueText2_h.setAttribute('text-anchor', 'start');
        valueText2_h.setAttribute('alignment-baseline', 'middle');
        valueText2_h.setAttribute('font-size', '10');
        valueText2_h.textContent = value;
        svg.appendChild(valueText2_h);
    });
   } // <-- if (hasSecondDataset) 블록 끝

     // 범례 추가 (Horizontal)
        const legendGroup_h = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        // 수직 차트와 동일한 위치(우측 상단)에 배치합니다.
        legendGroup_h.setAttribute('transform', `translate(${svgWidth - 200}, 40)`);
        
        // 첫 번째 시리즈 범례 요소들 (선, 점, 텍스트)
        const legendLine1_h = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        legendLine1_h.setAttribute('x1', 0);
        legendLine1_h.setAttribute('y1', 0);
        legendLine1_h.setAttribute('x2', 30);
        legendLine1_h.setAttribute('y2', 0);
        legendLine1_h.setAttribute('stroke', primaryColor);
        legendLine1_h.setAttribute('stroke-width', '2');
        legendGroup_h.appendChild(legendLine1_h);
        
        const legendCircle1_h = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        legendCircle1_h.setAttribute('cx', 15);
        legendCircle1_h.setAttribute('cy', 0);
        legendCircle1_h.setAttribute('r', '3');
        legendCircle1_h.setAttribute('fill', primaryColor);
        legendGroup_h.appendChild(legendCircle1_h);
        
        const legendText1_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        legendText1_h.setAttribute('x', 40);
        legendText1_h.setAttribute('y', 5);
        legendText1_h.setAttribute('font-size', '12');
        legendText1_h.textContent = seriesLabels[0]; // CSV 데이터 603의 첫 번째 값 또는 기본값
        legendGroup_h.appendChild(legendText1_h);
        
        // 두 번째 시리즈 범례 (데이터가 있을 경우에만 추가)
        if (hasSecondDataset) {
            const legendLine2_h = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            legendLine2_h.setAttribute('x1', 100); // X 위치를 조정하여 첫 번째 범례 옆에 오도록 합니다.
            legendLine2_h.setAttribute('y1', 0);
            legendLine2_h.setAttribute('x2', 130);
            legendLine2_h.setAttribute('y2', 0);
            legendLine2_h.setAttribute('stroke', secondaryColor);
            legendLine2_h.setAttribute('stroke-width', '2');
            legendGroup_h.appendChild(legendLine2_h);
        
            const legendCircle2_h = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            legendCircle2_h.setAttribute('cx', 115); // X 위치 조정
            legendCircle2_h.setAttribute('cy', 0);
            legendCircle2_h.setAttribute('r', '3');
            legendCircle2_h.setAttribute('fill', secondaryColor);
            legendGroup_h.appendChild(legendCircle2_h);
        
            const legendText2_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            legendText2_h.setAttribute('x', 140); // X 위치 조정
            legendText2_h.setAttribute('y', 5);
            legendText2_h.setAttribute('font-size', '12');
            legendText2_h.textContent = seriesLabels[1]; // CSV 데이터 603의 두 번째 값 또는 기본값
            legendGroup_h.appendChild(legendText2_h);
        }
        svg.appendChild(legendGroup_h); // 완성된 범례 그룹 전체를 SVG에 추가합니다.
  
      // (여기에 다음 단계 코드가 계속 추가될 예정입니다)
     } // <-- else 끝
}

  // 비교 차트를 SVG로 렌더링
function renderSimpleComparisonChart(container, data) {
  const labels = data['601'] || [];   // 예: ['크기','속도','성능',…]
  const valuesA = data['701'] || [];   // 첫 번째 제품 값 배열
  const valuesB = data['702'] || [];   // 두 번째 제품 값 배열
  const series = data['603'] || ['A','B'];
  const chartTitle = data['401'] || '비교 차트';
  const scheme         = getColorScheme(data['302']);
  const primaryColor   = scheme[0] || '#4285F4';
  const secondaryColor = scheme[1] || '#EA4335';
  const maxValue = Math.max(
    ...valuesA.map(v=>+v||0),
    ...valuesB.map(v=>+v||0)
  );
  
  // SVG 크기 설정
  const svgWidth = 800;
  const svgHeight = 500;
  const paddingX = 60;
  const paddingY = 80;
  const chartWidth = svgWidth - 2 * paddingX;
  const chartHeight = svgHeight - 2 * paddingY;
  
  // 레이아웃 옵션 읽기 (getLayoutOption 헬퍼 함수 사용)
  const layout = getLayoutOption(data['301']); // 예: 'side-by-side', 'split-screen', 'default' 등 예상
  console.log('Comparison chart layout:', layout); // 실제 어떤 레이아웃 값이 읽혔는지 콘솔에 출력 (디버깅용)
   
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // layout 값에 따라 분기 시작
  if (layout === 'vertical' || layout === 'default') {
    console.log('Rendering comparison chart as: Side-by-Side Vertical Bars'); // 임시 확인용 로그
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // X축 추가
  const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  xAxis.setAttribute('x1', paddingX);
  xAxis.setAttribute('y1', svgHeight - paddingY);
  xAxis.setAttribute('x2', svgWidth - paddingX);
  xAxis.setAttribute('y2', svgHeight - paddingY);
  xAxis.setAttribute('stroke', '#333');
  xAxis.setAttribute('stroke-width', '1');
  svg.appendChild(xAxis);
  
  // 막대 너비 및 간격 계산
  const groupWidth = chartWidth / labels.length;
  const barWidth = groupWidth / 3;
  const barSpacing = barWidth / 2;
  
  // 각 그룹의 막대 생성
  for (let i = 0; i < labels.length; i++) {
    const x = paddingX + i * groupWidth + groupWidth / 4;
    
    // 첫 번째 막대 (A)
    const valueA = +valuesA[i] || 0;
    const heightA = (valueA / maxValue) * chartHeight;
    const barA = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    barA.setAttribute('x', x);
    barA.setAttribute('y', svgHeight - paddingY - heightA);
    barA.setAttribute('width', barWidth);
    barA.setAttribute('height', heightA);
    barA.setAttribute('fill', primaryColor);
    svg.appendChild(barA);
    
    // 첫 번째 막대 값 라벨
    const labelA = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    labelA.setAttribute('x', x + barWidth / 2);
    labelA.setAttribute('y', svgHeight - paddingY - heightA - 5);
    labelA.setAttribute('text-anchor', 'middle');
    labelA.setAttribute('font-size', '12');
    labelA.textContent = valueA;
    svg.appendChild(labelA);
    
    // 두 번째 막대 (B)
    const valueB = +valuesB[i] || 0;
    const heightB = (valueB / maxValue) * chartHeight;
    const barB = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    barB.setAttribute('x', x + barWidth + barSpacing);
    barB.setAttribute('y', svgHeight - paddingY - heightB);
    barB.setAttribute('width', barWidth);
    barB.setAttribute('height', heightB);
    barB.setAttribute('fill', secondaryColor);
    svg.appendChild(barB);
    
    // 두 번째 막대 값 라벨
    const labelB = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    labelB.setAttribute('x', x + barWidth * 1.5 + barSpacing);
    labelB.setAttribute('y', svgHeight - paddingY - heightB - 5);
    labelB.setAttribute('text-anchor', 'middle');
    labelB.setAttribute('font-size', '12');
    labelB.textContent = valueB;
    svg.appendChild(labelB);
    
    // X축 라벨
    const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    xLabel.setAttribute('x', x + barWidth + barSpacing / 2);
    xLabel.setAttribute('y', svgHeight - paddingY + 20);
    xLabel.setAttribute('text-anchor', 'middle');
    xLabel.setAttribute('font-size', '12');
    xLabel.textContent = labels[i];
    svg.appendChild(xLabel);
  }
  
  // 범례 추가
  // 범례 상자
  const legendBox = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  legendBox.setAttribute('x', svgWidth - 150);
  legendBox.setAttribute('y', 50);
  legendBox.setAttribute('width', 120);
  legendBox.setAttribute('height', 50);
  legendBox.setAttribute('fill', 'white');
  legendBox.setAttribute('stroke', '#ddd');
  legendBox.setAttribute('stroke-width', '1');
  svg.appendChild(legendBox);
  
  // 첫 번째 시리즈 범례
  const legendA = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  legendA.setAttribute('x', svgWidth - 140);
  legendA.setAttribute('y', 60);
  legendA.setAttribute('width', 15);
  legendA.setAttribute('height', 15);
  legendA.setAttribute('fill', primaryColor);
  svg.appendChild(legendA);
  
  const legendTextA = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  legendTextA.setAttribute('x', svgWidth - 120);
  legendTextA.setAttribute('y', 72);
  legendTextA.setAttribute('font-size', '12');
  legendTextA.textContent = series[0];
  svg.appendChild(legendTextA);
  
  // 두 번째 시리즈 범례
  const legendB = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  legendB.setAttribute('x', svgWidth - 140);
  legendB.setAttribute('y', 80);
  legendB.setAttribute('width', 15);
  legendB.setAttribute('height', 15);
  legendB.setAttribute('fill', secondaryColor);
  svg.appendChild(legendB);
  
  const legendTextB = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  legendTextB.setAttribute('x', svgWidth - 120);
  legendTextB.setAttribute('y', 92);
  legendTextB.setAttribute('font-size', '12');
  legendTextB.textContent = series[1];
  svg.appendChild(legendTextB);
    
  } else if (layout === 'horizontal') {
     // --- 수평 비교 차트 (Horizontal Side-by-Side Bars) 로직 시작 ---

      // 1. 축 그리기
      
      // 세로축 (항목/카테고리 축) - Y축 역할
      const yAxis_h = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      yAxis_h.setAttribute('x1', paddingX);                 // 왼쪽 시작 X
      yAxis_h.setAttribute('y1', paddingY);                 // 위쪽 시작 Y
      yAxis_h.setAttribute('x2', paddingX);                 // 왼쪽 끝 X (수직선)
      yAxis_h.setAttribute('y2', paddingY + chartHeight); // 아래쪽 끝 Y
      yAxis_h.setAttribute('stroke', '#333');               // 축 색상
      yAxis_h.setAttribute('stroke-width', '1');            // 축 두께
      svg.appendChild(yAxis_h);                             // SVG에 추가
      
      // 가로축 (값 축) - X축 역할
      const xAxis_h = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      xAxis_h.setAttribute('x1', paddingX);                 // 왼쪽 시작 X
      xAxis_h.setAttribute('y1', paddingY + chartHeight); // 아래쪽 시작 Y
      xAxis_h.setAttribute('x2', paddingX + chartWidth);  // 오른쪽 끝 X
      xAxis_h.setAttribute('y2', paddingY + chartHeight); // 아래쪽 끝 Y (수평선)
      xAxis_h.setAttribute('stroke', '#333');               // 축 색상
      xAxis_h.setAttribute('stroke-width', '1');            // 축 두께
      svg.appendChild(xAxis_h);                             // SVG에 추가

       const gridLines = 5; // 5개의 그리드 라인/눈금 구간을 사용합니다.
   for (let i = 0; i <= gridLines; i++) {
      // 현재 눈금/그리드 라인이 위치할 X 좌표를 계산합니다.
      const x = paddingX + (i / gridLines) * chartWidth;
      // 현재 눈금에 해당하는 값을 계산합니다. (0부터 maxValue까지)
      const value = (i / gridLines) * maxValue;
  
      // 세로 그리드 라인 생성
      const gridLine_h = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      gridLine_h.setAttribute('x1', x);
      gridLine_h.setAttribute('y1', paddingY); // 차트 영역 상단에서 시작
      gridLine_h.setAttribute('x2', x);
      gridLine_h.setAttribute('y2', paddingY + chartHeight); // 차트 영역 하단까지
      gridLine_h.setAttribute('stroke', '#e0e0e0'); // 그리드 라인 색상
      gridLine_h.setAttribute('stroke-width', '1'); // 그리드 라인 두께
      svg.appendChild(gridLine_h);
  
      // 가로축 (값) 레이블 생성
      const xLabel_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      xLabel_h.setAttribute('x', x); // 해당 눈금의 X 좌표
      xLabel_h.setAttribute('y', paddingY + chartHeight + 20); // 가로축 선보다 20px 아래
      xLabel_h.setAttribute('text-anchor', 'middle'); // 텍스트 중앙 정렬
      xLabel_h.setAttribute('font-size', '12'); // 글자 크기
      // 값의 크기에 따라 소수점 표시 여부 결정 (간단한 방식)
      xLabel_h.textContent = maxValue < 10 && maxValue > 0 ? value.toFixed(1) : Math.round(value);
      svg.appendChild(xLabel_h);
  }

      // 세로축 (항목/카테고리) 레이블 추가
      const groupHeight = chartHeight / (labels.length || 1); // 각 항목(카테고리) 그룹이 차지할 세로 높이를 계산합니다. (0으로 나누는 오류 방지)
      labels.forEach((label, i) => {
      // 현재 레이블이 위치할 Y 좌표를 계산합니다. (각 그룹의 세로 중앙 지점)
      const y = paddingY + i * groupHeight + groupHeight / 2;
  
      // 세로축 레이블 텍스트 요소를 생성합니다.
      const yLabel_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      yLabel_h.setAttribute('x', paddingX - 10); // 세로축 선(yAxis_h)보다 10px 왼쪽에 위치시킵니다.
      yLabel_h.setAttribute('y', y);             // 위에서 계산한 Y 좌표 (그룹의 중앙)에 배치합니다.
      yLabel_h.setAttribute('text-anchor', 'end'); // 텍스트의 끝(오른쪽)을 기준점(x 좌표)에 맞춰 정렬합니다.
      yLabel_h.setAttribute('alignment-baseline', 'middle'); // 텍스트의 세로 중앙을 기준점(y 좌표)에 맞춥니다.
      yLabel_h.setAttribute('font-size', '12'); // 글자 크기를 설정합니다.
      yLabel_h.textContent = label; // labels 배열에서 가져온 실제 항목 텍스트를 표시합니다.
      svg.appendChild(yLabel_h); // 생성한 레이블을 SVG에 추가합니다.
    });

      // 4. 가로 막대 및 값 레이블 그리기

      // 각 항목 그룹 내에서 막대의 높이와 막대 간 간격을 계산합니다.
      // groupHeight는 이전 단계(세로축 레이블 추가)에서 이미 계산되었습니다.
      const barHeight = groupHeight / 3; // 각 막대의 높이를 그룹 높이의 1/3로 설정
      const barSpacing = barHeight / 2;  // A 막대와 B 막대 사이의 수직 간격
  
      // 각 항목(label)에 대해 루프를 실행합니다.
     for (let i = 0; i < labels.length; i++) {
      // 현재 항목 그룹의 시작 Y 좌표
      const yGroupStart = paddingY + i * groupHeight;
      // A 막대의 Y 좌표 계산 (그룹 내에서 약간 위쪽에 위치)
      const yA = yGroupStart + (groupHeight / 2) - barHeight - (barSpacing / 2); // 그룹 중앙보다 위쪽
      // B 막대의 Y 좌표 계산 (A 막대 바로 아래에 간격을 두고 위치)
      const yB = yA + barHeight + barSpacing;
  
      // --- 데이터 A (첫 번째 데이터셋) 막대 및 레이블 ---
      const valueA = Number(valuesA[i] || 0); // 현재 항목의 A 값
      // 값에 비례하는 막대 너비 계산 (maxValue가 0이면 너비도 0)
      const widthA = maxValue === 0 ? 0 : (valueA / maxValue) * chartWidth;
  
      // A 막대 (rect 요소) 생성
      const barA_h = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      barA_h.setAttribute('x', paddingX);      // 모든 막대는 왼쪽 축(paddingX)에서 시작
      barA_h.setAttribute('y', yA);            // 계산된 A 막대의 Y 위치
      barA_h.setAttribute('width', widthA);    // 계산된 A 막대의 너비
      barA_h.setAttribute('height', barHeight);// 위에서 정의한 막대 높이
      barA_h.setAttribute('fill', primaryColor); // 첫 번째 시리즈 색상 사용
      svg.appendChild(barA_h);                 // SVG에 A 막대 추가
  
      // A 값 레이블 (text 요소) 생성
      const labelA_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      labelA_h.setAttribute('x', paddingX + widthA + 5); // 막대 끝에서 오른쪽으로 5px 이동
      labelA_h.setAttribute('y', yA + barHeight / 2);    // 막대의 세로 중앙 위치
      labelA_h.setAttribute('text-anchor', 'start');     // 텍스트 시작점을 x 좌표에 맞춤
      labelA_h.setAttribute('alignment-baseline', 'middle'); // 텍스트 세로 중앙 정렬
      labelA_h.setAttribute('font-size', '12');          // 글자 크기
      labelA_h.textContent = valueA;                     // 실제 A 값 표시
      svg.appendChild(labelA_h);                         // SVG에 A 값 레이블 추가
  
      // --- 데이터 B (두 번째 데이터셋) 막대 및 레이블 ---
      const valueB = Number(valuesB[i] || 0); // 현재 항목의 B 값
      // 값에 비례하는 막대 너비 계산
      const widthB = maxValue === 0 ? 0 : (valueB / maxValue) * chartWidth;
  
      // B 막대 (rect 요소) 생성
      const barB_h = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      barB_h.setAttribute('x', paddingX);
      barB_h.setAttribute('y', yB);            // 계산된 B 막대의 Y 위치
      barB_h.setAttribute('width', widthB);    // 계산된 B 막대의 너비
      barB_h.setAttribute('height', barHeight);
      barB_h.setAttribute('fill', secondaryColor); // 두 번째 시리즈 색상 사용
      svg.appendChild(barB_h);
  
      // B 값 레이블 (text 요소) 생성
      const labelB_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      labelB_h.setAttribute('x', paddingX + widthB + 5); // 막대 끝에서 오른쪽으로 5px 이동
      labelB_h.setAttribute('y', yB + barHeight / 2);    // 막대의 세로 중앙 위치
      labelB_h.setAttribute('text-anchor', 'start');
      labelB_h.setAttribute('alignment-baseline', 'middle');
      labelB_h.setAttribute('font-size', '12');
      labelB_h.textContent = valueB;                     // 실제 B 값 표시
      svg.appendChild(labelB_h);
  }
      // 5. 범례 추가 (Horizontal)

      // 범례를 감싸는 흰색 배경 상자 (테두리 포함)
      const legendBox_h = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      legendBox_h.setAttribute('x', svgWidth - 150); // 범례 상자 X 좌표 (우측 정렬)
      legendBox_h.setAttribute('y', 50);            // 범례 상자 Y 좌표 (상단에서 50px 아래)
      legendBox_h.setAttribute('width', 120);       // 범례 상자 너비
      legendBox_h.setAttribute('height', 50);       // 범례 상자 높이
      legendBox_h.setAttribute('fill', 'white');    // 배경색 흰색
      legendBox_h.setAttribute('stroke', '#ddd');   // 테두리색 연한 회색
      legendBox_h.setAttribute('stroke-width', '1');
      svg.appendChild(legendBox_h);
      
      // 첫 번째 시리즈 (A) 범례 항목 (색상 사각형 + 텍스트)
      const legendA_h = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      legendA_h.setAttribute('x', svgWidth - 140); // 상자 내부 X 좌표
      legendA_h.setAttribute('y', 60);            // 상자 내부 Y 좌표
      legendA_h.setAttribute('width', 15);        // 색상 사각형 너비
      legendA_h.setAttribute('height', 15);       // 색상 사각형 높이
      legendA_h.setAttribute('fill', primaryColor); // 시리즈 A 색상
      svg.appendChild(legendA_h);
      
      const legendTextA_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      legendTextA_h.setAttribute('x', svgWidth - 120); // 텍스트 X 좌표 (사각형 오른쪽)
      legendTextA_h.setAttribute('y', 72);            // 텍스트 Y 좌표 (사각형과 높이 맞춤)
      legendTextA_h.setAttribute('font-size', '12');
      legendTextA_h.textContent = series[0];        // 시리즈 A 이름 (CSV 603 또는 기본값 'A')
      svg.appendChild(legendTextA_h);
      
      // 두 번째 시리즈 (B) 범례 항목 (색상 사각형 + 텍스트)
      const legendB_h = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      legendB_h.setAttribute('x', svgWidth - 140); // 상자 내부 X 좌표
      legendB_h.setAttribute('y', 80);            // 상자 내부 Y 좌표 (A 범례 아래)
      legendB_h.setAttribute('width', 15);
      legendB_h.setAttribute('height', 15);
      legendB_h.setAttribute('fill', secondaryColor); // 시리즈 B 색상
      svg.appendChild(legendB_h);
      
      const legendTextB_h = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      legendTextB_h.setAttribute('x', svgWidth - 120); // 텍스트 X 좌표
      legendTextB_h.setAttribute('y', 92);            // 텍스트 Y 좌표 (A 범례 아래)
      legendTextB_h.setAttribute('font-size', '12');
      legendTextB_h.textContent = series[1];        // 시리즈 B 이름 (CSV 603 또는 기본값 'B')
      svg.appendChild(legendTextB_h);
  
  } //<-- if 끝
  // 참고: 현재 getLayoutOption 함수는 'vertical', 'horizontal', 'default' 중 하나만 반환하므로,
  // 모든 경우를 처리하기 위한 별도의 else 블록은 필수는 아닐 수 있습니다.
  
}
  
 // 프로세스 다이어그램을 SVG로 렌더링
function renderSimpleProcessDiagram(container, data) {
  const steps = data['601'] || [];
  const descriptions = data['701'] || [];
 // const isHorizontal = data['301'] && data['301'].toLowerCase().includes('horizontal');
  const layout = getLayoutOption(data['301']);
  const isHorizontal = (layout === 'horizontal');
  const chartTitle = data['401'] || '프로세스 다이어그램';
  const scheme = getColorScheme(data['302']);
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정 (가로형/세로형에 따라 다르게)
  const svgWidth = isHorizontal ? 900 : 600;
  const svgHeight = isHorizontal ? 700 : Math.max(400, steps.length * 120);
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 색상 계산 함수
  // function getColor(index) {
  //   const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8334A2'];
  //  return colors[index % colors.length];
  // }
 // ▶︎ 설명 줄 수 & 박스 높이 계산 (if문 바깥에서 한 번만 선언)
    const lineHeight  = 16;                                 
    const verticalPad = 20;                                
    const descCounts  = descriptions.map(d => d.split('\n').length);
  //  const boxHeight   = Math.max(...descCounts) * lineHeight + verticalPad;
    const centerY     = 100;
  //  const boxY        = centerY - boxHeight / 2;
    
    if (isHorizontal) {
      // 수평 프로세스 다이어그램
      svg.setAttribute('height', svgHeight);
      const boxWidth      = 120;
      const arrowLength   = 40;
      const svgWidth = (boxWidth + arrowLength) * steps.length + 200;
      const startY        = centerY;  // 필요 시 유지
   
    for (let i = 0; i < steps.length; i++) {
      const descCount = descriptions[i] ? descriptions[i].split('\n').length : 1;
      const x = 60 + i * (boxWidth + arrowLength);
      const color = scheme[i % scheme.length];
      // 현재 단계의 설명 가져오기 및 줄 수 계산
      const currentDesc = descriptions[i] || '';
      const descLines = currentDesc.split('\\n');
      const descLineCount = descLines.length;
  
      // 박스 높이 계산 (제목 1줄 + 설명 줄 수 + 패딩 고려)
      const currentBoxHeight = (1 + descLineCount) * lineHeight + verticalPad;
      const boxY = centerY - currentBoxHeight / 2; // 박스의 Y 좌표 계산
      
      // 프로세스 박스
      const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      box.setAttribute('x', x);
      box.setAttribute('y', boxY);
      box.setAttribute('width', boxWidth);
      box.setAttribute('height', currentBoxHeight);
      box.setAttribute('rx', '6');
      box.setAttribute('ry', '6');
      box.setAttribute('fill', color);
      svg.appendChild(box);
      
      // 단계 텍스트
      const stepText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      stepText.setAttribute('x', x + boxWidth / 2);
      stepText.setAttribute('y', boxY + 25);
      stepText.setAttribute('text-anchor', 'middle');
      stepText.setAttribute('dominant-baseline', 'middle');
      stepText.setAttribute('fill', 'white');
      stepText.setAttribute('font-size', '14');
      stepText.setAttribute('font-weight', 'bold');
      stepText.textContent = steps[i];
      svg.appendChild(stepText);
      
     // 설명 텍스트 (줄바꿈 처리 - tspan 사용)
        if (descriptions[i]) {
          const descLines = descriptions[i].split('\n'); // '\n' 기준으로 줄 나누기

          if (descLines.length > 0) {
            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            // 텍스트 블록 시작 위치 설정: 박스 바로 아래, 왼쪽 정렬 기준
            textElement.setAttribute('x', x + boxWidth / 2); // 박스의 시작 x 좌표 사용
            textElement.setAttribute('y', boxY + currentBoxHeight + 20); // 박스 하단 + 20px 여백
            textElement.setAttribute('text-anchor', 'middle'); // 가운 정렬
            textElement.setAttribute('font-size', '12');
            textElement.setAttribute('fill', '#333'); // 텍스트 색상 (흰색 배경에 잘 보이도록)

            // 각 줄을 tspan으로 추가
            descLines.forEach((line, j) => {
              const tspanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
              tspanElement.setAttribute('x', x + boxWidth / 2); // 각 줄의 시작 x 좌표를 동일하게 설정
              if (j > 0) {
                // 첫 번째 줄 이후에는 줄 간격(dy) 설정
                tspanElement.setAttribute('dy', '1.2em'); 
              }
              tspanElement.textContent = line; // 현재 줄 텍스트 설정
              textElement.appendChild(tspanElement); // text 요소에 tspan 추가
            });
            svg.appendChild(textElement); // 완성된 text 요소 SVG에 추가
          }
        }
      
      // 화살표 (마지막 항목 제외)
      if (i < steps.length - 1) {
        const arrowX = x + boxWidth;
        const arrowY = centerY;
        
        // 화살표 선
        const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        arrowLine.setAttribute('x1', arrowX);
        arrowLine.setAttribute('y1', arrowY);
        arrowLine.setAttribute('x2', arrowX + arrowLength);
        arrowLine.setAttribute('y2', arrowY);
        arrowLine.setAttribute('stroke', '#666');
        arrowLine.setAttribute('stroke-width', '2');
        svg.appendChild(arrowLine);
        
        // 화살표 머리
        const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        arrowHead.setAttribute('d', `M ${arrowX + arrowLength - 10} ${arrowY - 6} L ${arrowX + arrowLength} ${arrowY} L ${arrowX + arrowLength - 10} ${arrowY + 6}`);
        arrowHead.setAttribute('fill', 'none');
        arrowHead.setAttribute('stroke', '#666');
        arrowHead.setAttribute('stroke-width', '2');
        svg.appendChild(arrowHead);
      }
    }
  } else {
    // 수직 프로세스 다이어그램
    const boxWidth = 300;
   // const boxHeight = 80;
    const arrowLength = 40;
    const startX = (svgWidth - boxWidth) / 2;
    
    for (let i = 0; i < steps.length; i++) {
      const color = scheme[i % scheme.length];
      // 현재 단계의 설명 가져오기 및 줄 수 계산
      const currentDesc = descriptions[i] || '';
      const descLines = currentDesc.split('\\n');
      const descLineCount = descLines.length;

      // lineHeight 선언 (★★ 여기로 이동 ★★)
      const lineHeight = 16;
  
      // 박스 높이 계산 (제목 1줄 + 설명 줄 수 + 패딩 고려)
      const currentBoxHeight = (1 + descLineCount) * lineHeight + verticalPad;
      // y 선언 (위치 이동됨!)
      const y = 80 + i * (currentBoxHeight + arrowLength);
      
      // 프로세스 박스
      const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      box.setAttribute('x', startX);
      box.setAttribute('y', y);
      box.setAttribute('width', boxWidth);
      box.setAttribute('height', currentBoxHeight);
      box.setAttribute('rx', '6');
      box.setAttribute('ry', '6');
      box.setAttribute('fill', color);
      svg.appendChild(box);
      
      // 단계 텍스트
      const stepText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      stepText.setAttribute('x', startX + boxWidth / 2);
      stepText.setAttribute('y', y + 25);
      stepText.setAttribute('text-anchor', 'middle');
      stepText.setAttribute('fill', 'white');
      stepText.setAttribute('font-size', '14');
      stepText.setAttribute('font-weight', 'bold');
      stepText.textContent = steps[i];
      svg.appendChild(stepText);
      
      // 설명 텍스트 (줄바꿈 처리)
      if (descriptions[i]) {
        const descLines = descriptions[i].split('\\n');
        
        for (let j = 0; j < descLines.length; j++) {
          if (j < 3) { // 최대 3줄로 제한
            const descText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            descText.setAttribute('x', startX + boxWidth / 2);
            descText.setAttribute('y', y + 45 + j * lineHeight);
            descText.setAttribute('text-anchor', 'middle');
            descText.setAttribute('fill', 'white');
            descText.setAttribute('font-size', '12');
            descText.textContent = descLines[j];
            svg.appendChild(descText);
          }
        }
      }
      
      // 화살표 (마지막 항목 제외)
      if (i < steps.length - 1) {
        const arrowX = startX + boxWidth / 2;
        const arrowY = y + currentBoxHeight;
        
        // 화살표 선
        const arrowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        arrowLine.setAttribute('x1', arrowX);
        arrowLine.setAttribute('y1', arrowY);
        arrowLine.setAttribute('x2', arrowX);
        arrowLine.setAttribute('y2', arrowY + arrowLength);
        arrowLine.setAttribute('stroke', '#666');
        arrowLine.setAttribute('stroke-width', '2');
        svg.appendChild(arrowLine);
        
        // 화살표 머리
        const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        arrowHead.setAttribute('d', `M ${arrowX - 6} ${arrowY + arrowLength - 10} L ${arrowX} ${arrowY + arrowLength} L ${arrowX + 6} ${arrowY + arrowLength - 10}`);
        arrowHead.setAttribute('fill', 'none');
        arrowHead.setAttribute('stroke', '#666');
        arrowHead.setAttribute('stroke-width', '2');
        svg.appendChild(arrowHead);
      }
    }
  }
}

 // 타임라인을 SVG로 렌더링
function renderSimpleTimeline(container, data) {
  const events = data['601'] || [];
  const titles = data['701'] || [];
  const descriptions = data['702'] || [];
 // const isVertical = data['301'] && data['301'].toLowerCase().includes('vertical');
  const layout = getLayoutOption(data['301']);
  const isVertical = (layout === 'vertical');
  const chartTitle = data['401'] || '타임라인';
  const scheme = getColorScheme(data['302']);
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정
  const svgWidth = isVertical ? 700 : Math.max(800, events.length * 150);
  const svgHeight = isVertical ? Math.max(400, events.length * 120) : 500;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 색상 계산 함수
  // function getColor(index) {
  //  const colors = ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8334A2'];
  //  return colors[index % colors.length];
  // }
  
  if (isVertical) {
    // 수직 타임라인
    const centerX = 150;
    const startY = 80;
    const itemHeight = 100;
    
    // 중앙 선
    const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    centerLine.setAttribute('x1', centerX);
    centerLine.setAttribute('y1', startY);
    centerLine.setAttribute('x2', centerX);
    centerLine.setAttribute('y2', startY + itemHeight * events.length);
    centerLine.setAttribute('stroke', '#ddd');
    centerLine.setAttribute('stroke-width', '4');
    svg.appendChild(centerLine);
    
    for (let i = 0; i < events.length; i++) {
      const y = startY + i * itemHeight;
      const color = getPaletteColor(i, data['302']);
      const isRight = i % 2 === 0; // 왼쪽/오른쪽 번갈아가며 배치
      
      // 이벤트 원
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', centerX);
      circle.setAttribute('cy', y + 20);
      circle.setAttribute('r', '10');
      circle.setAttribute('fill', color);
      svg.appendChild(circle);
      
      // 이벤트 날짜/시간
      const timeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      timeText.setAttribute('x', isRight ? centerX - 20 : centerX + 20);
      timeText.setAttribute('y', y + 25);
      timeText.setAttribute('text-anchor', isRight ? 'end' : 'start');
      timeText.setAttribute('font-size', '14');
      timeText.setAttribute('font-weight', 'bold');
      timeText.textContent = events[i];
      svg.appendChild(timeText);
      
      // 이벤트 내용 박스
      const boxWidth = 250;
      const boxHeight = 70;
      const boxX = isRight ? centerX + 30 : centerX - 30 - boxWidth;
      
      const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      box.setAttribute('x', boxX);
      box.setAttribute('y', y - 10);
      box.setAttribute('width', boxWidth);
      box.setAttribute('height', boxHeight);
      box.setAttribute('rx', '5');
      box.setAttribute('fill', '#f8f9fa');
      box.setAttribute('stroke', color);
      box.setAttribute('stroke-width', '2');
      svg.appendChild(box);
      
      // 이벤트 제목
      const titleText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      titleText.setAttribute('x', boxX + 10);
      titleText.setAttribute('y', y + 15);
      titleText.setAttribute('font-size', '14');
      titleText.setAttribute('font-weight', 'bold');
      titleText.setAttribute('fill', color);
      titleText.textContent = titles[i] || '';
      svg.appendChild(titleText);
      
      // 이벤트 설명
      if (descriptions[i]) {
        const descText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        descText.setAttribute('x', boxX + 10);
        descText.setAttribute('y', y + 40);
        descText.setAttribute('font-size', '12');
        
        // 설명 텍스트 (글자수 제한)
        let desc = descriptions[i];
        if (desc.length > 60) {
          desc = desc.substring(0, 57) + '...';
        }
        descText.textContent = desc;
        svg.appendChild(descText);
      }
      
      // 연결선
      const connectorStartX = isRight ? centerX + 10 : centerX - 10;
      const connectorEndX = isRight ? boxX : boxX + boxWidth;
      
      const connector = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      connector.setAttribute('x1', connectorStartX);
      connector.setAttribute('y1', y + 20);
      connector.setAttribute('x2', connectorEndX);
      connector.setAttribute('y2', y + 20);
      connector.setAttribute('stroke', color);
      connector.setAttribute('stroke-width', '2');
      svg.appendChild(connector);
    }
  } else {
    // 수평 타임라인
    const centerY = 180;
    const startX = 80;
    const itemWidth = (svgWidth - 160) / events.length;
    
    // 중앙 선
    const centerLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    centerLine.setAttribute('x1', startX);
    centerLine.setAttribute('y1', centerY);
    centerLine.setAttribute('x2', svgWidth - 80);
    centerLine.setAttribute('y2', centerY);
    centerLine.setAttribute('stroke', '#ddd');
    centerLine.setAttribute('stroke-width', '4');
    svg.appendChild(centerLine);
    
    for (let i = 0; i < events.length; i++) {
      const x = startX + i * itemWidth;
      const scheme = getColorScheme(data['302']);
      const color  = scheme[i % scheme.length];
      const isTop = i % 2 === 0; // 위/아래 번갈아가며 배치
      
      // 이벤트 원
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', x + itemWidth / 2);
      circle.setAttribute('cy', centerY);
      circle.setAttribute('r', '10');
      circle.setAttribute('fill', color);
      svg.appendChild(circle);
      
      // 이벤트 날짜/시간
      const timeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      timeText.setAttribute('x', x + itemWidth / 2);
      timeText.setAttribute('y', isTop ? centerY + 30 : centerY - 15);
      timeText.setAttribute('text-anchor', 'middle');
      timeText.setAttribute('font-size', '14');
      timeText.setAttribute('font-weight', 'bold');
      timeText.textContent = events[i];
      svg.appendChild(timeText);
      
      // 이벤트 내용 박스
      const boxWidth = itemWidth - 20;
      const boxHeight = 70;
      const boxY = isTop ? centerY - boxHeight - 20 : centerY + 20;
      
      const box = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      box.setAttribute('x', x + 10);
      box.setAttribute('y', boxY);
      box.setAttribute('width', boxWidth);
      box.setAttribute('height', boxHeight);
      box.setAttribute('rx', '5');
      box.setAttribute('fill', '#f8f9fa');
      box.setAttribute('stroke', color);
      box.setAttribute('stroke-width', '2');
      svg.appendChild(box);
      
      // 이벤트 제목
      const titleText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      titleText.setAttribute('x', x + itemWidth / 2);
      titleText.setAttribute('y', boxY + 20);
      titleText.setAttribute('text-anchor', 'middle');
      titleText.setAttribute('font-size', '14');
      titleText.setAttribute('font-weight', 'bold');
      titleText.setAttribute('fill', color);
      titleText.textContent = titles[i] || '';
      svg.appendChild(titleText);
      
      // 이벤트 설명
      if (descriptions[i]) {
        const descText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        descText.setAttribute('x', x + itemWidth / 2);
        descText.setAttribute('y', boxY + 45);
        descText.setAttribute('text-anchor', 'middle');
        descText.setAttribute('font-size', '12');
        
        // 설명 텍스트 (글자수 제한)
        let desc = descriptions[i];
        if (desc.length > 30) {
          desc = desc.substring(0, 27) + '...';
        }
        descText.textContent = desc;
        svg.appendChild(descText);
      }
      
      // 연결선
      const connectorStartY = isTop ? centerY - 10 : centerY + 10;
      const connectorEndY = isTop ? boxY + boxHeight : boxY;
      
      const connector = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      connector.setAttribute('x1', x + itemWidth / 2);
      connector.setAttribute('y1', connectorStartY);
      connector.setAttribute('x2', x + itemWidth / 2);
      connector.setAttribute('y2', connectorEndY);
      connector.setAttribute('stroke', color);
      connector.setAttribute('stroke-width', '2');
      svg.appendChild(connector);
    }
  }
}
  
  // 간단한 레이더 차트 렌더링
function renderSimpleRadarChart(container, data) {
  const labels = data['601'] || [];
  const dataset1 = data['701'] || [];
  const dataset2 = data['702'] || [];
  const hasSecondDataset = Array.isArray(dataset2) && dataset2.length > 0;
  const seriesLabels = data['603'] || ['시리즈 1', '시리즈 2'];
  const chartTitle = data['401'] || '레이더 차트';
  const scheme = getColorScheme(data['302']);

  // 최대값 계산
  const allValues = [...dataset1];
  if (hasSecondDataset) allValues.push(...dataset2);
  const maxValue = Math.max(...allValues.map(v => Number(v) || 0));
  
  // 컨테이너 초기화
  container.innerHTML = '';
  
  // SVG 크기 설정
  const svgWidth = 800;
  const svgHeight = 500;
  
  // SVG 요소 생성
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', svgHeight);
  svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  container.appendChild(svg);
  
  // 제목 추가
  const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  titleElement.setAttribute('x', svgWidth / 2);
  titleElement.setAttribute('y', 30);
  titleElement.setAttribute('text-anchor', 'middle');
  titleElement.setAttribute('font-size', '20');
  titleElement.setAttribute('font-weight', 'bold');
  titleElement.textContent = chartTitle;
  svg.appendChild(titleElement);
  
  // 중심점과 반지름
  const centerX = svgWidth / 2;
  const centerY = svgHeight / 2;
  const radius = Math.min(svgWidth, svgHeight) * 0.35;
  const numPoints = labels.length;
  const angleStep = (Math.PI * 2) / numPoints;
  
  // 배경 그리드 그리기
  const levels = 5;
  for (let i = 1; i <= levels; i++) {
    const gridRadius = (radius * i) / levels;
    let pathData = "";
    
    for (let j = 0; j < numPoints; j++) {
      const angle = -Math.PI/2 + j * angleStep;
      const x = centerX + gridRadius * Math.cos(angle);
      const y = centerY + gridRadius * Math.sin(angle);
      
      if (j === 0) {
        pathData += `M ${x} ${y} `;
      } else {
        pathData += `L ${x} ${y} `;
      }
    }
    pathData += "Z";
    
    const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    gridPath.setAttribute('d', pathData);
    gridPath.setAttribute('fill', 'none');
    gridPath.setAttribute('stroke', '#ddd');
    gridPath.setAttribute('stroke-width', '1');
    svg.appendChild(gridPath);
    
    // 값 표시 (선택적)
    if (i === levels) {
      for (let j = 0; j < numPoints; j++) {
        const angle = -Math.PI/2 + j * angleStep;
        const labelValue = i;
        
        // 값 위치 조정
        const textX = centerX + (gridRadius + 15) * Math.cos(angle);
        const textY = centerY + (gridRadius + 15) * Math.sin(angle);
        
        const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        valueLabel.setAttribute('x', textX);
        valueLabel.setAttribute('y', textY);
        valueLabel.setAttribute('text-anchor', 'middle');
        valueLabel.setAttribute('font-size', '10');
        valueLabel.setAttribute('fill', '#999');
        valueLabel.textContent = labelValue;
        svg.appendChild(valueLabel);
      }
    }
  }
  
  // 축 그리기
  for (let i = 0; i < numPoints; i++) {
    const angle = -Math.PI/2 + i * angleStep;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    
    const axisLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    axisLine.setAttribute('x1', centerX);
    axisLine.setAttribute('y1', centerY);
    axisLine.setAttribute('x2', x);
    axisLine.setAttribute('y2', y);
    axisLine.setAttribute('stroke', '#ddd');
    axisLine.setAttribute('stroke-width', '1');
    svg.appendChild(axisLine);
    
    // 레이블 위치 계산 및 그리기
    const labelDistance = radius + 25; // 레이블과 차트 사이 간격 늘림
    const labelX = centerX + labelDistance * Math.cos(angle);
    const labelY = centerY + labelDistance * Math.sin(angle);
    
    const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    labelText.setAttribute('x', labelX);
    labelText.setAttribute('y', labelY);
    labelText.setAttribute('text-anchor', 'middle');
    labelText.setAttribute('dominant-baseline', 'middle');
    labelText.setAttribute('font-size', '12');
    labelText.textContent = labels[i] || `항목 ${i+1}`;
    svg.appendChild(labelText);
  }
  
  // 첫 번째 데이터셋 폴리곤 그리기
  drawDataPolygon(dataset1, getPaletteColor(0, data['302']), 0.6);
  
  // 두 번째 데이터셋이 있으면 그리기
  if (hasSecondDataset) {
    drawDataPolygon(dataset2, getPaletteColor(1, data['302']), 0.6);
  }
  
  // 범례 추가
  const legendGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  legendGroup.setAttribute('transform', `translate(${centerX - 100}, ${centerY + radius + 40})`);
  
  // 첫 번째 데이터셋 범례
  const legendRect1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
  legendRect1.setAttribute('x', '0');
  legendRect1.setAttribute('y', '0');
  legendRect1.setAttribute('width', '15');
  legendRect1.setAttribute('height', '15');
  legendRect1.setAttribute('fill', getPaletteColor(0));
  legendRect1.setAttribute('fill-opacity', '0.6');
  legendRect1.setAttribute('style', `fill: ${getPaletteColor(0)}; fill-opacity: 0.6;`);
  legendGroup.appendChild(legendRect1);
  
  const legendText1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  legendText1.setAttribute('x', '25');
  legendText1.setAttribute('y', '12');
  legendText1.setAttribute('font-size', '12');
  legendText1.textContent = seriesLabels[0] || "시리즈 1";
  legendGroup.appendChild(legendText1);
  
  if (hasSecondDataset) {
    // 두 번째 데이터셋 범례
    const legendRect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    legendRect2.setAttribute('x', '100');
    legendRect2.setAttribute('y', '0');
    legendRect2.setAttribute('width', '15');
    legendRect2.setAttribute('height', '15');
    legendRect2.setAttribute('fill', getPaletteColor(1));
    legendRect2.setAttribute('fill-opacity', '0.6');
    legendRect2.setAttribute('style', `fill: ${getPaletteColor(1)}; fill-opacity: 0.6;`);
    legendGroup.appendChild(legendRect2);
    
    const legendText2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    legendText2.setAttribute('x', '125');
    legendText2.setAttribute('y', '12');
    legendText2.setAttribute('font-size', '12');
    legendText2.textContent = seriesLabels[1] || "시리즈 2";
    legendGroup.appendChild(legendText2);
  }
  
  svg.appendChild(legendGroup);
  
  // 데이터 폴리곤 그리기 함수
  function drawDataPolygon(dataset, color, opacity) {
    // 폴리곤 경로 생성
    let polygonPath = "";
    
    for (let i = 0; i < numPoints; i++) {
      const value = i < dataset.length ? Number(dataset[i]) || 0 : 0;
      const ratio = Math.min(value / maxValue, 1);
      const angle = -Math.PI/2 + i * angleStep;
      const x = centerX + radius * ratio * Math.cos(angle);
      const y = centerY + radius * ratio * Math.sin(angle);
      
      if (i === 0) {
        polygonPath += `M ${x} ${y} `;
      } else {
        polygonPath += `L ${x} ${y} `;
      }
    }
    
    polygonPath += "Z"; // 경로 닫기
    
    // 폴리곤 추가
    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    polygon.setAttribute('d', polygonPath);
    polygon.setAttribute('fill', color);
    polygon.setAttribute('fill-opacity', String(opacity));
    polygon.setAttribute('stroke', color);
    polygon.setAttribute('stroke-width', '2');
    polygon.setAttribute('style', `fill: ${color}; fill-opacity: ${opacity}; stroke: ${color};`);
    svg.appendChild(polygon);
    
    // 데이터 포인트와 값 추가
    for (let i = 0; i < numPoints; i++) {
      const value = i < dataset.length ? Number(dataset[i]) || 0 : 0;
      const ratio = Math.min(value / maxValue, 1);
      const angle = -Math.PI/2 + i * angleStep;
      const x = centerX + radius * ratio * Math.cos(angle);
      const y = centerY + radius * ratio * Math.sin(angle);
      
      // 데이터 포인트
      const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      dot.setAttribute('cx', String(x));
      dot.setAttribute('cy', String(y));
      dot.setAttribute('r', '4');
      dot.setAttribute('fill', color);
      dot.setAttribute('style', `fill: ${color};`);
      svg.appendChild(dot);
      
      // 값 라벨
      const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      valueText.setAttribute('x', String(x));
      valueText.setAttribute('y', String(y - 10));
      valueText.setAttribute('text-anchor', 'middle');
      valueText.setAttribute('font-size', '11');
      valueText.setAttribute('fill', color);
      valueText.setAttribute('font-weight', 'bold');
      valueText.textContent = value;
      svg.appendChild(valueText);
    }
  }
}
  
 // 인포그래픽 생성 버튼에 이벤트 리스너 연결
  document.getElementById('generate-button').addEventListener('click', function() {
    console.log('인포그래픽 생성 버튼 클릭됨');
    
    try {
      // CSV 데이터 가져오기
      const csvInput = document.getElementById('csv-input');
      const csvText = csvInput.value;
      console.log('CSV 데이터:', csvText); // CSV 내용 확인
      
      // CSV 파싱
      const parseResult = parseCSVData(csvText);
      const data = parseResult.data;
      
      // 레이아웃 값 확인 로그 추가
      console.log('레이아웃 설정:', data['301']);
      console.log('시각화 유형:', data['101']);
      
      // 미리보기 컨테이너 가져오기
      const previewContainer = document.getElementById('preview-container');
      
      // 기존 내용 제거 (메모리 누수 방지)
      previewContainer.innerHTML = '';
      
      // 인포그래픽 렌더링
      renderSimpleChart(previewContainer, data);
      
      // 다운로드 버튼 활성화
      const downloadButton = document.getElementById('download-button');
      if (downloadButton) {
        downloadButton.disabled = false;
      }
    } catch (error) {
      console.error('인포그래픽 생성 중 오류:', error);
      
      // 오류 메시지 표시
      const errorContainer = document.getElementById('error-container');
      if (errorContainer) {
        errorContainer.innerHTML = `<div class="alert alert-danger">인포그래픽 생성 중 오류가 발생했습니다: ${error.message}</div>`;
      }
    }
  });
});
// “초기화” 버튼 클릭 시 동작
document.getElementById('clear-button').addEventListener('click', function() {
  // 1) CSV 입력란 비우기
  document.getElementById('csv-input').value = '';
  // 2) 미리보기 기본 안내로 리셋
  document.getElementById('preview-container').innerHTML = `
    <div style="text-align: center; color: #6b7280;">
      <i class="fas fa-chart-bar" style="font-size: 3rem; margin-bottom: 1rem;"></i>
      <p>인포그래픽을 생성하려면 CSV 데이터를 입력하고 '인포그래픽 생성' 버튼을 클릭하세요.</p>
    </div>
  `;
  // 3) 다운로드 버튼 비활성화
  const dl = document.getElementById('download-button');
  if (dl) dl.disabled = true;
});

// "SVG 다운로드" 버튼 클릭 시 동작
// "SVG 다운로드" 버튼 클릭 시 동작
document.getElementById('download-button').addEventListener('click', function() {
  const previewContainer = document.getElementById('preview-container');
  
  // SVG 요소 찾기
  let svg = previewContainer.querySelector('svg');
  
  if (!svg) {
    alert('다운로드할 SVG가 없습니다. 다른 차트 유형을 선택해보세요.');
    return;
  }
  
  // SVG 복제 (원본 변경 방지)
  let clonedSvg = svg.cloneNode(true);
  
  // SVG에 인라인 스타일 추가 (더 명시적인 스타일)
  let styles = `
    <defs>
      <style>
        text { font-family: Arial, sans-serif; fill: #000000; }
        path { stroke-linecap: round; stroke-linejoin: round; }
        rect { stroke-linecap: round; stroke-linejoin: round; }
        circle { stroke-linecap: round; stroke-linejoin: round; }
        line { stroke-linecap: round; stroke-linejoin: round; }
      </style>
    </defs>
  `;
  
  // 모든 투명도 속성을 명시적으로 설정
  // 경로(path) 요소 처리 (레이더 차트, 파이 차트 등)
  const pathElements = clonedSvg.querySelectorAll('path');
  pathElements.forEach(el => {
    const fillColor = el.getAttribute('fill');
    if (fillColor && fillColor !== 'none') {
      // 기존 투명도 값 가져오기 (없으면 기본값 사용)
      let opacity = el.getAttribute('fill-opacity') || '1';
      
      // 레이더 차트 폴리곤 여부 확인 (투명도가 필요한지 판단)
      if (el.hasAttribute('stroke') && el.getAttribute('stroke-width') === '2') {
        // 레이더 차트 폴리곤으로 추정
        opacity = '0.6';
      }
      
      // 인라인 스타일과 속성 모두 설정
      el.setAttribute('fill', fillColor);
      el.setAttribute('fill-opacity', opacity);
      el.setAttribute('style', `fill: ${fillColor}; fill-opacity: ${opacity};`);
    }
    
    // 선 색상도 처리
    const strokeColor = el.getAttribute('stroke');
    if (strokeColor && strokeColor !== 'none') {
      el.setAttribute('style', (el.getAttribute('style') || '') + ` stroke: ${strokeColor};`);
    }
  });
  
  // 사각형(rect) 요소 처리 (범례 등)
  const rectElements = clonedSvg.querySelectorAll('rect');
  rectElements.forEach(el => {
    const fillColor = el.getAttribute('fill');
    if (fillColor && fillColor !== 'none') {
      // 기존 투명도 값 가져오기 (없으면 기본값 사용)
      let opacity = el.getAttribute('fill-opacity') || '1';
      
      // 레이더 차트 범례 여부 확인
      if (opacity !== '1' || el.getAttribute('width') === '15' && el.getAttribute('height') === '15') {
        // 범례로 추정, 투명도 명시적 설정
        opacity = opacity || '0.6';
      }
      
      // 인라인 스타일과 속성 모두 설정
      el.setAttribute('fill', fillColor);
      el.setAttribute('fill-opacity', opacity);
      el.setAttribute('style', `fill: ${fillColor}; fill-opacity: ${opacity};`);
    }
  });
  
  // 네임스페이스 설정 (중요)
  clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  clonedSvg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
  
  // viewBox 확인 및 설정
  if (!clonedSvg.getAttribute('viewBox')) {
    const width = clonedSvg.getAttribute('width') || '800';
    const height = clonedSvg.getAttribute('height') || '600';
    clonedSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  }
  
  // 스타일 삽입
  clonedSvg.innerHTML = styles + clonedSvg.innerHTML;
  
  // SVG 문자열로 직렬화
  const serializer = new XMLSerializer();
  const source = serializer.serializeToString(clonedSvg);
  
  // Blob 생성
  const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  
  // 가상의 a 태그로 다운로드 트리거
  const a = document.createElement('a');
  a.href = url;
  a.download = 'infographic.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

</script>
  
</body>
</html>
